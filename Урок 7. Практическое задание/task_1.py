"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в виде функции.

Обязательно доработайте алгоритм (сделайте его умнее).

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение. Обязательно сделайте замеры времени обеих реализаций
и укажите дала ли оптимизация эффективность.

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.

Сделайте выводы!!!
Опишите в чем была ваша доработка и помогла ли вам доработка??
"""
from random import randint
from timeit import timeit

""" 
Я изначально оптимизировал алгоритм, пойдя с конца в обратную сторону по range. Кроме того, избавился от медленного 
цикла while и некоторых лишних переменных и сравнений
"""


def bubble(li):
    for i in range(len(li) - 1, 0, -1):
        for j in range(i):
            if li[j] < li[j + 1]:
                li[j], li[j + 1] = li[j + 1], li[j]

    return li


# [99, 91, 71, 69, 60, 50, 45, 44, 43, 37, 35, 26, 20, 15, 15, 14, -3, -4, -4, -5, -13, -15, -18, -28, -60, -80, -81,
# -90, -92, -96] 4.6111891

# Дальше по ТЗ вводим счетчик n, который увеличивается на 1 на каждой сортировке j и если при полном прохождении цикла
# j == i n - нулевое, сортировки не было, возвращаем массив

def bubble_upd_1(li):
    for i in range(len(li) - 1, 0, -1):
        for j in range(i):
            n = 0
            if li[j] < li[j + 1]:
                li[j], li[j + 1] = li[j + 1], li[j]
                n += 1
            if not n and j == i:
                return li
    return li


# [99, 91, 71, 69, 60, 50, 45, 44, 43, 37, 35, 26, 20, 15, 15, 14, -3, -4, -4, -5, -13, -15, -18, -28, -60, -80, -81,
# -90, -92, -96] 5.3967176 ничего не дало, даже работет как будто медленнее. Скорее всего, связано с ненужным
# дополнительным сравнением условий. Ну а шансов получить отсортированный массив изначально нет.

def bubble_upd_2(li):
    n = 0
    for i in range(len(li) - 1, n, -1):
        for j in range(i):
            if li[j] > li[j - 1]:
                li[j], li[j - 1] = li[j - 1], li[j]
        n += 1
    return li


# тут добавил то самое уменьшение кол-ва пробегов, о котором говорилось на уроке на словах. Начинаем с конца range, идем
# в обратную сторону, конец интервала нарастает по мере сортировки. Это дает небольшую оптмизацию, как видим. Но совсем
# небольшую

# [99, 91, 71, 69, 60, 50, 45, 44, 43, 37, 35, 26, 20, 15, 15, 14, -3, -4, -4, -5, -13, -15, -18, -28, -60, -80, -81,
# # -90, -92, -96] 4.41039301

# Для сравнения - возьмем пример с урока, без изменений(Ну только порядок сортировки поменяем на decs)

def bubble_sort(lst_obj):
    n = 1
    while n < len(lst_obj):
        for i in range(len(lst_obj) - n):
            if lst_obj[i] < lst_obj[i + 1]:
                lst_obj[i], lst_obj[i + 1] = lst_obj[i + 1], lst_obj[i]
        n += 1
    return lst_obj


#  [99, 91, 71, 69, 60, 50, 45, 44, 43, 37, 35, 26, 20, 15, 15, 14, -3, -4, -4, -5, -13, -15, -18, -28, -60, -80, -81,
#  -90, -92, -96] 5.01039301

# Общий вывод - первая функция достаточно уже оптмизирована, небольшое улучшение можно получить. Лучше скрипта с урока,
# но разница не столь существенна

if __name__ == '__main__':
    ml = [randint(-100, 100) for x in range(30)]
    print(bubble(ml[:]), timeit("bubble(ml[:])", globals=globals(), number=100000))
    print(bubble_upd_1(ml[:]), timeit("bubble_upd_1(ml[:])", globals=globals(), number=100000))
    print(bubble_upd_2(ml[:]), timeit("bubble_upd_2(ml[:])", globals=globals(), number=100000))
    print(bubble_sort(ml[:]), timeit("bubble_sort(ml[:])", globals=globals(), number=100000))
