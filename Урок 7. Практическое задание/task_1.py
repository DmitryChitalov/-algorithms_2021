"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в
виде функции.

Обязательно доработайте алгоритм (сделайте его умнее)!

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение.
Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.

Сделайте выводы!!!
Опишите в чем была ваша доработка и помогла ли вам доработка??
"""


from random import randint as rnd
from timeit import timeit


def bubble_sort(ar):  # Вариант с урока
    n = 1
    while n < len(ar):
        for i in range(len(ar)-n):
            if ar[i] < ar[i + 1]:
                ar[i], ar[i + 1] = ar[i + 1], ar[i]
        n += 1
    return ar


def bubble_sort_1(ar):  # Вариант без цикла while
    for run in range(len(ar)-1):
        for i in range(len(ar)-1):
            if ar[i] < ar[i + 1]:
                ar[i], ar[i + 1] = ar[i + 1], ar[i]
    return ar


def bubble_sort_2(ar):  # Вариант с "доработкой"
    leave = True  # флаг для остановки цикла
    while leave:
        leave = False  # если все на своих местах и выходим из цикла
        for i in range(len(ar)-1):
            if ar[i] < ar[i + 1]:
                ar[i], ar[i + 1] = ar[i + 1], ar[i]
                leave = True  # если делали перестановку и снова заходим в цикл
    return ar


if __name__ == '__main__':

    # замеры 10
    print(f'{"*" * 25} Замеры 10 {"*" * 25}')
    arr_10 = [rnd(-100, 100) for _ in range(10)]
    print(f'Вариант с урока {timeit("bubble_sort(arr_10[:])", globals=globals(), number=1000)}')
    print(f'Вариант без цикла while {timeit("bubble_sort_1(arr_10[:])", globals=globals(), number=1000)}')
    print(f'Вариант с "доработкой" {timeit("bubble_sort_2(arr_10[:])", globals=globals(), number=1000)}')
    # Вывод исходного и отсортированного по убыванию массива
    print(arr_10)
    print(bubble_sort_2(arr_10[:]))

    # замеры 100
    print(f'{"*" * 25} Замеры 100 {"*" * 25}')
    arr_100 = [rnd(-100, 100) for _ in range(100)]
    print(f'Вариант с урока {timeit("bubble_sort(arr_100[:])", globals=globals(), number=1000)}')
    print(f'Вариант без цикла while {timeit("bubble_sort_1(arr_100[:])", globals=globals(), number=1000)}')
    print(f'Вариант с "доработкой" {timeit("bubble_sort_2(arr_100[:])", globals=globals(), number=1000)}')

    # замеры 1000
    print(f'{"*" * 25} Замеры 1000 {"*" * 25}')
    arr_1000 = [rnd(-100, 100) for _ in range(1000)]
    print(f'Вариант с урока {timeit("bubble_sort(arr_1000[:])", globals=globals(), number=1000)}')
    print(f'Вариант без цикла while {timeit("bubble_sort_1(arr_1000[:])", globals=globals(), number=1000)}')
    print(f'Вариант с "доработкой" {timeit("bubble_sort_2(arr_1000[:])", globals=globals(), number=1000)}')

"""

Идея "Доработки" сортировки в установке флага, который меняется если нет перестановок(отсортировано)
Такой подход не дает прироста скорости, только если на малом кол-ве, а при больших замерах,
шанс что будет массив отсортирован крайне малы, по цифрам даже видно его отставание по времени
за счет постоянной проверки на предмет выхода их цикла...

> Исходный и отсортированный по убыванию массив <
[-16, -53, 28, 42, -91, 27, -38, 65, -41, -12]
[65, 42, 28, 27, -12, -16, -38, -41, -53, -91]

************************* Замеры 10 *************************
Вариант с урока 0.00721503300000001
Вариант без цикла while 0.008643454000000023
Вариант с "доработкой" 0.008505972
************************* Замеры 100 *************************
Вариант с урока 0.42947956600000003
Вариант без цикла while 0.650103147
Вариант с "доработкой" 0.586131674
************************* Замеры 1000 *************************
Вариант с урока 52.866272262
Вариант без цикла while 82.79353079400002
Вариант с "доработкой" 82.56617062799998
"""
