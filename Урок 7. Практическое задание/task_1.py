"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в
виде функции.

Обязательно доработайте алгоритм (сделайте его умнее)!

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение
Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.

Сделайте выводы!!!
Опишите в чем была ваша доработка и помогла ли вам доработка??
"""

import random

from timeit import timeit


def sort_reverse(list_arg):

    n = 0

    while n < len(list_arg):

        for i in range(len(list_arg)-1-n):

            if list_arg[i] < list_arg[i+1]:

                list_arg[i], list_arg[i+1] = list_arg[i+1], list_arg[i]
        n += 1

    return list_arg


def sort_reverse_second(list_arg):

    n = 0
    while n < len(list_arg):

        status = True

        for i in range(len(list_arg)-1-n):

            if list_arg[i] < list_arg[i+1]:

                list_arg[i], list_arg[i+1] = list_arg[i+1], list_arg[i]

                status = False

        if status:

            break

        n += 1

    return list_arg


'''
-----------------------------------------------------------------------------------------------------------------------
Доработка: проверка является ли список отсартированным на абсолютно каждом этапе. Экономия времени происходит
за счет того, что если список уже отсортирован, проверки не осуществляются.
-----------------------------------------------------------------------------------------------------------------------
'''


original_list = [random.randint(-100, 100) for i in range(100)]

print(timeit('sort_reverse(original_list[:])', globals=globals(), number=10000))

print(timeit('sort_reverse_second(original_list[:])', globals=globals(), number=10000))

'''
-----------------------------------------------------------------------------------------------------------------------
До тех пор, пока мы передаем неотсортированный список, разница между двумя способами
реализации не будет существенно видна. (см. Результаты)
-----------------------------------------------------------------------------------------------------------------------
Результат:
-----------------------------------------------------------------------------------------------------------------------
5.545599
5.4826776
-----------------------------------------------------------------------------------------------------------------------
'''

sorted_list = sorted(original_list, reverse=True)

print(timeit('sort_reverse(sorted_list[:])', globals=globals(), number=10000))

print(timeit('sort_reverse_second(sorted_list[:])', globals=globals(), number=10000))

'''
-----------------------------------------------------------------------------------------------------------------------
Здесь мы передаем уже отсортированный список, и здесь мы можем увидеть существенную разницу.
То, что second работает быстрее и в разы (см. Результаты).
-----------------------------------------------------------------------------------------------------------------------
Результат:
-----------------------------------------------------------------------------------------------------------------------
2.578239
0.05225640000000098
-----------------------------------------------------------------------------------------------------------------------
'''
