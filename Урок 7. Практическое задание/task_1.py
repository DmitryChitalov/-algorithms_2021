"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в виде функции.

Обязательно доработайте алгоритм (сделайте его умнее).

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение. Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.

Сделайте выводы!!!
Опишите в чем была ваша доработка и помогла ли вам доработка??
"""

from random import randint
from timeit import timeit

orig_list = [randint(-100, 100) for _ in range(10)]
print('Исходный массив:', orig_list)
srt_lst = sorted(orig_list)
srt_lst.reverse()
print('Массив, отсортированный встроенными методами.', srt_lst)

###################################### Алгоритм из материалов к уроку ######################################
print('###################################### Алгоритм из материалов к уроку ######################################')

# Алгоритм уже несколько оптимизирован (как на уроке в разборе говорилось), по отсортированному не ходим.

"""Сортировка пузырьком"""


def bubble_sort(lst_obj):
    n = 1
    while n < len(lst_obj):
        for i in range(len(lst_obj) - n):
            if lst_obj[i] < lst_obj[i + 1]:  # Поменяем знак, чтобы добиться убывания. Всплывает самый маленький.
                lst_obj[i], lst_obj[i + 1] = lst_obj[i + 1], lst_obj[i]
        n += 1
    return lst_obj


print('Отсортированный массив:', bubble_sort(orig_list[:]))

###################################### + Проверка на отсортированность ######################################
print('###################################### + Проверка на отсортированность ######################################')


def bubble_sort1(lst_obj):
    n = 1
    flag = True
    while n < len(lst_obj) and flag:
        flag = False
        for i in range(len(lst_obj) - n):
            if lst_obj[i] < lst_obj[i + 1]:
                flag = True
                lst_obj[i], lst_obj[i + 1] = lst_obj[i + 1], lst_obj[i]
        n += 1
    return lst_obj


print('Отсортированный массив:', bubble_sort1(orig_list[:]))

###################################### + Запоминание последнего обмена ######################################
print('###################################### + Запоминание последнего обмена ######################################')


def bubble_sort2(lst_obj):
    n = 1
    last_permutation_index = 0
    right_serif = len(lst_obj)
    while n < len(lst_obj):
        for i in range(len(lst_obj) - n):
            if lst_obj[i] < lst_obj[i + 1]:  # Поменяем знак, чтобы добиться убывания. Всплывает самый маленький.
                lst_obj[i], lst_obj[i + 1] = lst_obj[i + 1], lst_obj[i]
                last_permutation_index = i + 1
        n += right_serif - last_permutation_index
        if right_serif > last_permutation_index:
            right_serif = last_permutation_index
        else:
            break
    return lst_obj


print('Отсортированный массив:', bubble_sort2(orig_list[:]))
###################################### Замеры ######################################
print('###################################### Замеры ######################################')
# замеры 10
print('Замеры 10.   Исходная сортировка.', timeit("bubble_sort(orig_list[:])", globals=globals(), number=10))
# замеры 100
print('Замеры 100.  Исходная сортировка.', timeit("bubble_sort(orig_list[:])", globals=globals(), number=100))
# замеры 1000
print('Замеры 1000. Исходная сортировка.', timeit("bubble_sort(orig_list[:])", globals=globals(), number=1000))
print('Замеры 1000. Исходная сортировка на заранее отсортированном массиве',
      timeit("bubble_sort(srt_lst[:])", globals=globals(), number=1000))
print()
# замеры 10
print('Замеры 10.   + Проверка на отсортированность',
      timeit("bubble_sort1(orig_list[:])", globals=globals(), number=10))
# замеры 100
print('Замеры 100.  + Проверка на отсортированность',
      timeit("bubble_sort1(orig_list[:])", globals=globals(), number=100))
# замеры 1000
print('Замеры 1000. + Проверка на отсортированность',
      timeit("bubble_sort1(orig_list[:])", globals=globals(), number=1000))
print('Замеры 1000. + Проверка на отсортированность на заранее отсортированном массиве',
      timeit("bubble_sort1(srt_lst[:])", globals=globals(), number=1000))
print()
# замеры 10
print('Замеры 10.   + Запоминание последнего обмена',
      timeit("bubble_sort2(orig_list[:])", globals=globals(), number=10))
# замеры 100
print('Замеры 100.  + Запоминание последнего обмена',
      timeit("bubble_sort2(orig_list[:])", globals=globals(), number=100))
# замеры 1000
print('Замеры 1000. + Запоминание последнего обмена',
      timeit("bubble_sort2(orig_list[:])", globals=globals(), number=1000))
print('Замеры 1000. + Запоминание последнего обмена на заранее отсортированном массиве',
      timeit("bubble_sort2(srt_lst[:])", globals=globals(), number=1000))

'''
Выводы:
Результаты замеров:

Исходный массив: [-6, 88, -80, 54, -25, -83, 44, -29, 13, -76]

Замеры 10.   Исходная сортировка. 8.94999999999993e-05
Замеры 100.  Исходная сортировка. 0.0009259999999999963
Замеры 1000. Исходная сортировка. 0.009151
Замеры 1000. Исходная сортировка на заранее отсортированном массиве 0.005759999999999994

Замеры 10.   + Проверка на отсортированность 7.83999999999993e-05
Замеры 100.  + Проверка на отсортированность 0.0008815000000000003
Замеры 1000. + Проверка на отсортированность 0.008085800000000004
Замеры 1000. + Проверка на отсортированность на заранее отсортированном массиве 0.0012193000000000065

Замеры 10.   + Запоминание последнего обмена 7.840000000000624e-05
Замеры 100.  + Запоминание последнего обмена 0.0007547999999999999
Замеры 1000. + Запоминание последнего обмена 0.007517999999999997
Замеры 1000. + Запоминание последнего обмена на заранее отсортированном массиве 0.0012645000000000017

Видно, что оптимизации дают каждая свой небольшой прирост в производительности. Можно было бы еще дооптимизировать.
Если в начале массива не было несколько раз перестановок, можно следующие сравнения начинать не сначала.
Но реализовывать это не стал. Оно подобно третьей реализации алгоритма из написанных выше.
'''