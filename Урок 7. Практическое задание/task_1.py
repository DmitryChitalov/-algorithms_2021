"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в
виде функции.

Обязательно доработайте алгоритм (сделайте его умнее)!

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение.
Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.

Сделайте выводы!!!
Опишите в чем была ваша доработка и помогла ли вам доработка??
"""

from random import randint
from timeit import default_timer, repeat


def bubble_sort(lst_obj):
    n = 1
    while n < len(lst_obj):
        for i in range(len(lst_obj)-n):
            if lst_obj[i] > lst_obj[i+1]:
                lst_obj[i], lst_obj[i+1] = lst_obj[i+1], lst_obj[i]
        n += 1
    return lst_obj


def bubble_sort_from_end_with_checking(lst_obj):
    n = len(lst_obj) - 1
    end = 0
    while n >= end:
        is_changed = False
        for i in range(n, end, -1):
            if lst_obj[i - 1] > lst_obj[i]:
                lst_obj[i], lst_obj[i - 1] = lst_obj[i - 1], lst_obj[i]
                is_changed = True
        if not is_changed:
            break
        end += 1
    return lst_obj


def comb_sort(lst_obj):
    alen = len(lst_obj)
    gap = (alen * 10 // 13) if alen > 1 else 0
    while gap:
        swapped = False
        for i in range(alen - gap):
            if lst_obj[i + gap] < lst_obj[i]:
                lst_obj[i], lst_obj[i + gap] = lst_obj[i + gap], lst_obj[i]
                swapped = True
        gap = (gap * 10 // 13) or swapped
    return lst_obj


def new_lists():
    orig_list1 = [randint(-100, 100) for _ in range(10)]
    orig_list2 = [randint(-100, 100) for _ in range(100)]
    orig_list3 = [randint(-100, 100) for _ in range(500)]
    orig_list4 = [randint(-100, 100) for _ in range(1000)]
    orig_list5 = [randint(-100, 100) for _ in range(3000)]

    return orig_list1, orig_list2, orig_list3, orig_list4, orig_list5


orig_list = [randint(-100, 100) for _ in range(1000)]
print(orig_list)
print(bubble_sort(orig_list[:]))
print(bubble_sort_from_end_with_checking(orig_list[:]))
print(comb_sort(orig_list[:]))
# Функции дают одинаковый результат

explore_functions = ['bubble_sort', 'bubble_sort_from_end_with_checking', 'comb_sort']

for test_number in range(1, 4):
    print(f'Тест {test_number}', end='\n\n')
    explore_lists = new_lists()

    for function in explore_functions:
        print(f'Функция {function}')

        for explore_list in explore_lists:
            time_sec = min(repeat(
                f'{function}({explore_list[:]})', globals=globals(), timer=default_timer, repeat=3, number=1))

            print(f'Лучшее время на сортровку списка длинной {len(explore_list)}: {round(time_sec, 4)} сек')
        print('')


# Тест 1
#
# Функция bubble_sort                                          Функция bubble_sort_from_end_with_checking
# Лучшее время на сортровку списка длинной 10: 0.0 сек         Лучшее время на сортровку списка длинной 10: 0.0 сек
# Лучшее время на сортровку списка длинной 100: 0.0025 сек     Лучшее время на сортровку списка длинной 100: 0.0026 сек
# Лучшее время на сортровку списка длинной 500: 0.061 сек      Лучшее время на сортровку списка длинной 500: 0.0662 сек
# Лучшее время на сортровку списка длинной 1000: 0.2484 сек    Лучшее время на сортровку списка длинной 1000: 0.2745 сек
# Лучшее время на сортровку списка длинной 3000: 2.2233 сек    Лучшее время на сортровку списка длинной 3000: 2.3917 сек

# Тест 2
#
# Функция bubble_sort                                         Функция bubble_sort_from_end_with_checking
# Лучшее время на сортровку списка длинной 10: 0.0 сек        Лучшее время на сортровку списка длинной 10: 0.0 сек
# Лучшее время на сортровку списка длинной 100: 0.0023 сек    Лучшее время на сортровку списка длинной 100: 0.0024 сек
# Лучшее время на сортровку списка длинной 500: 0.0585 сек    Лучшее время на сортровку списка длинной 500: 0.0658 сек
# Лучшее время на сортровку списка длинной 1000: 0.2388 сек   Лучшее время на сортровку списка длинной 1000: 0.2652 сек
# Лучшее время на сортровку списка длинной 3000: 2.2167 сек   Лучшее время на сортровку списка длинной 3000: 2.3856 сек

# Тест 3
#
# Функция bubble_sort                                          Функция bubble_sort_from_end_with_checking
# Лучшее время на сортровку списка длинной 10: 0.0 сек         Лучшее время на сортровку списка длинной 10: 0.0 сек
# Лучшее время на сортровку списка длинной 100: 0.0023 сек     Лучшее время на сортровку списка длинной 100: 0.0024 сек
# Лучшее время на сортровку списка длинной 500: 0.0569 сек     Лучшее время на сортровку списка длинной 500: 0.063 сек
# Лучшее время на сортровку списка длинной 1000: 0.2387 сек    Лучшее время на сортровку списка длинной 1000: 0.2636 сек
# Лучшее время на сортровку списка длинной 3000: 2.2244 сек    Лучшее время на сортровку списка длинной 3000: 2.4098 сек

# Как видно из результатов тестирования, классический алгоритм сортировки методом пузырька с учетом
# отсортированной части отрабатывает лучше, чем его модификация.
# При сортировке по убыванию возникает ещё одна переменная, что несколько замедляет работу алгоритма.
#
# Что касается проверки отсортированности неотсортированной части списка, она может как дать положительный эффект,
# так и наоборот замедлить работу алгоритма.
# Для рандомно заполненных списков это, чаще всего, не даст лучшего результата.

# Функция comb_sort                                           Функция sorted
# Лучшее время на сортровку списка длинной 10: 0.0 сек        Лучшее время на сортровку списка длинной 10: 0.0 сек
# Лучшее время на сортровку списка длинной 100: 0.0005 сек    Лучшее время на сортровку списка длинной 100: 0.0 сек
# Лучшее время на сортровку списка длинной 500: 0.0034 сек    Лучшее время на сортровку списка длинной 500: 0.0001 сек
# Лучшее время на сортровку списка длинной 1000: 0.0076 сек   Лучшее время на сортровку списка длинной 1000: 0.0001 сек
# Лучшее время на сортровку списка длинной 3000: 0.0274 сек   Лучшее время на сортровку списка длинной 3000: 0.0005 сек

# Сортировка расческой, основанная на сортировке пузырьком, показывает значительно превосходящие результаты.
# Достигается это благодаря более широкому начальному шагу (расстоянию между проверяемыми числами),
# что позволяет "разглаживать" список, постепенно сводя значение шага к единице.
