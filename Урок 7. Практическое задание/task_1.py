"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в виде функции.

Обязательно доработайте алгоритм (сделайте его умнее).

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение. Обязательно сделайте замеры времени обеих реализаций
и укажите дала ли оптимизация эффективность.

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.

Сделайте выводы!!!
Опишите в чем была ваша доработка и помогла ли вам доработка??
"""

import timeit
import random


# Исходный вариант:
def bubble_sort(lst_obj):
    n = 1
    while n < len(lst_obj):
        for i in range(len(lst_obj)-1):
            if lst_obj[i] < lst_obj[i + 1]:
                lst_obj[i], lst_obj[i + 1] = lst_obj[i + 1], lst_obj[i]
        n += 1
    return lst_obj


# Оптимизированный вариант:
def best_bubble_sort(lst_obj):
    n = 1
    flag = True
    while n < len(lst_obj) and flag:  # n < len(lst_obj) лучше оставить, чтобы при замене последнего не выполнять проход
        flag = False
        for i in range(len(lst_obj) - n):
            if lst_obj[i] < lst_obj[i + 1]:  # по усл. 1 - меняем ">" на "<"
                flag = True  # по усл. 2
                lst_obj[i], lst_obj[i + 1] = lst_obj[i + 1], lst_obj[i]
        n += 1
    return lst_obj


# ---- Параметры замеров:
len_arr = [10, 20, 50, 100, 200, 300]           # размер сортируемого массива
res_time = {'Len_arr': ('bs', 'best_bs', '%')}    # словарь для результатов замеров

# --- Делаем замер и выводим результаты:
for len_i in len_arr:
    orig_list = [random.randint(-100, 100) for _ in range(len_i)]
    bs = timeit.timeit(
            "bubble_sort(orig_list[:])",
            globals=globals(), number=1000)
    best_bs = timeit.timeit(
            "best_bubble_sort(orig_list[:])",
            globals=globals(), number=1000)
    res_time[len_i] = (round(bs, 4), round(best_bs, 4),
                       round((best_bs/bs - 1)*100, 2))
    print(f'-- При длине массива: {len_i} ')
    print(f'Массив до сортировки: {orig_list}')
    print(f'Массив после сортировки bubble_sort или bs: {bubble_sort(orig_list[:])}')
    print(f'Массив после  best_bubble_sort или best_bs: {best_bubble_sort(orig_list[:])}')

# Выводим результаты
for pos, item in enumerate(res_time.items()):
    print(f'{pos})  {item[0]}   {item[1][0]}  {item[1][1]}   {item[1][2]}')

"""
Вывод:
В результате выполнения практического задания было сделано следующее:

1. Алгоритм стал сортировать массив по убыванию - изменили знак ">" на "<".

2. Добавлен триггер flag, который позволяет выйти из while при условии, что за
проход перестановок значений не происходило - т.е. массив уже отсортирован и следующие проход не нужны.

3. Добавлен шаг, уменьшающий проход по массиву на последующем цикле,
что позволяет экономить время за счет отсуствия необходимости прохода по отсортированным значениям
в конце массива.   

Результаты замеров показали, что оптимизированная функция best_bs работает быстрее исходного варианта.
При незначительном размере массива время уменьшается на 20-25%, а 
при увеличении массива, соотвественно, разница увеличивается - см. результаты ниже.  

Вывод результатов:

    ------ При длине массива: 10 
    Массив до сортировки: [-27, 37, -22, 48, -87, 51, 50, -46, -27, -52]
    Массив после сортировки bubble_sort или bs: [51, 50, 48, 37, -22, -27, -27, -46, -52, -87]
    Массив после  best_bubble_sort или best_bs: [51, 50, 48, 37, -22, -27, -27, -46, -52, -87]
... ------ При длине массива: 20 
... и т.д.

Сводные результаты замеров:

    №   Len_arr   bs     best_bs    %
    1)  10     0.0196  0.0149   -23.94
    2)  20     0.0632  0.0467   -26.12
    3)  50     0.3855  0.2755   -28.54
    4)  100    1.5687  1.0727   -31.62
    5)  200    6.0883  4.1939   -31.12
    6)  300    14.192  9.3739   -33.95
"""
