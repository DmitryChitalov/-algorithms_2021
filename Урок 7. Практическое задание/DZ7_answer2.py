"""
2. Отсортируйте по возрастанию методом слияния одномерный вещественный массив,
заданный случайными числами на промежутке [0; 50). Выведите на экран исходный
и отсортированный массивы.
Хотя в примерах к уроку уже есть вариант реализации слияния,
попробуйте предложить другой (придумать или найти).
И попытаться сделать замеры на массивах разной длины: 10, 100, 1000, ...
Пример:
Введите число элементов: 5
Исходный - [46.11436617832828, 41.62921998361278, 18.45859540989644, 12.128870723745806, 8.025098788570562]
Отсортированный - [8.025098788570562, 12.128870723745806, 18.45859540989644, 41.62921998361278, 46.11436617832828]
"""
from random import uniform
from timeit import timeit

def merge_sort(lst_obj):
    if len(lst_obj) < 2:
        return lst_obj
    else:
        base_element = lst_obj[0]
        small_element = [i for i in lst_obj[1:] if i < base_element]
        big_element = [i for i in lst_obj[1:] if i > base_element]

        return merge_sort(small_element) + [base_element] + merge_sort(big_element)

seq = [uniform(0, 50) for i in range(10)]

print(seq)
print(merge_sort(seq))

print(timeit('merge_sort(seq[:])', globals=globals(), number=1000))

'''
Результаты замеров:
10 эл. - 0.007323 с
100 эл. - 0.103359
1000 эл. - 1.345
10000 эл. - 17.1216

Видно, что увеличение числа элементов в массиве приводит к росту времени выполнения сортировки 
даже немного ниже, чем nlog(n)
'''

