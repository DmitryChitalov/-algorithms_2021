"""
3. Массив размером 2m + 1, где m – натуральное число, заполнен случайным образом.
Найдите в массиве медиану. Медианой называется элемент ряда, делящий его на
две равные по длине части: в одной находятся элементы, которые не меньше медианы,
в другой – не больше медианы.

Задачу можно решить без сортировки исходного
массива.

Но если это слишком сложно, то используйте метод сортировки,
который не рассматривался на уроках: Шелла, Гномья, Кучей...

[5, 3, 4, 3, 3, 3, 3]

[3, 3, 3, 3, 3, 4, 5]

my_lst
new_lts

arr[m]


from statistics import median

[3, 4, 3, 3, 5, 3, 3]


left.clear()
right.clear()


m = 3
len = 7
i
left = []
right = []

left == right and

for i in
    for
    left == right
    left.clear()
    right.clear()


"""
import random
import statistics
from timeit import timeit

m = int(input('Введите любое натуральное число: '))
length = 2 * m + 1  # длина массива по формуле 2m+1
test_massive = [random.randint(-100, 100) for _ in range(length)]  # Строим массив по формуле


# 1-е решение (с сортировкой Шелла)

def shell_sort(a):
    def new_increment(a):
        i = len(a) // 2
        yield i
        while i != 1:
            if i == 2:
                i = 1
            else:
                i = int(round(i / 2.2))
            yield i

    for increment in new_increment(a):
        for i in range(increment, len(a)):
            for j in range(i, increment - 1, -increment):
                if a[j - increment] < a[j]:
                    break
                a[j], a[j - increment] = a[j - increment], a[j]
    return a, a[len(a) // 2]  # возвращаем список и медиану


print(f'Медиана с помощью сортировки - {shell_sort(test_massive.copy())[1]}',  # ищем медиану
      end='\n-------------------------------------------------------------------------------------------------------\n')


# 2-е решение (без сортировки)

def my_median(lst_obj: list):
    while len(lst_obj) != 1:
        del lst_obj[lst_obj.index(max(lst_obj))], lst_obj[lst_obj.index(min(lst_obj))]
    return lst_obj[0]


print(f'Медиана через свою функцию - {my_median(test_massive.copy())}',
      end='\n-------------------------------------------------------------------------------------------------------\n')

# 3-е решение (Используя модуль statistics)

print(f'Медиана через модуль statistics - {statistics.median(test_massive.copy())}',
      end='\n-------------------------------------------------------------------------------------------------------\n')

# Замеры

print('Делаем замеры')
print('Медиана с помощью сортировки',
      round(timeit('shell_sort(test_massive.copy())[1]', number=100000, globals=globals()), 2),
      'сек')

print('Медиана через свою функцию',
      round(timeit('my_median(test_massive.copy())', number=100000, globals=globals()), 2),
      'сек')

print('Медиана через модуль statistics',
      round(timeit('statistics.median(test_massive.copy())', number=100000, globals=globals()), 2),
      'сек')

'''
Результат:
Введите любое натуральное число: 10
Медиана с помощью сортировки - 26
-------------------------------------------------------------------------------------------------------
Медиана через свою функцию - 26
-------------------------------------------------------------------------------------------------------
Медиана через модуль statistics - 26
-------------------------------------------------------------------------------------------------------
Делаем замеры
Медиана с помощью сортировки 4.42 сек
Медиана через свою функцию 1.41 сек
Медиана через модуль statistics 0.12 сек
Аналитика:
Согласно замерам, медиана с помощью сортировки ищется дольше всего
Своя функция, где удаляется максимальный и минимальный элемент чуть быстрее
И самая быстрая оказалась функция median из модуля statistics, т.к это встроенное решение, лучше использовать его
'''
