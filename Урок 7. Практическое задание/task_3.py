"""
3. Массив размером 2m + 1, где m – натуральное число, заполнен случайным образом.
Найдите в массиве медиану. Медианой называется элемент ряда, делящий его на
две равные по длине части: в одной находятся элементы, которые не меньше медианы,
в другой – не больше медианы.

Задачу можно решить без сортировки исходного массива.

Но если это слишком сложно, то используйте метод сортировки,
который не рассматривался на уроках: Шелла, Гномья, Кучей...

Важно: стройте массив именно по формуле 2m+1
Потому что параметр m вам пригодится при поиске медианы, когда массив будет отсортирован.
Этот парамет m вам нужно запрашивать у пользователя.
"""
from random import random
from statistics import median
from timeit import timeit


# ###########################################################################################################
#                                                                                                           #
# Вариант без сортировки                                                                                    #
#                                                                                                           #
# ###########################################################################################################
def get_median_max_min(array):
    spam = array.copy()

    # Поскольку мы точно знаем из условия задачи, что массив с нечётным количеством элементов, медианой будет элемент,
    # больше и меньше которого будет одинаковое количество элементов
    while len(spam) > 1:
        spam.pop(spam.index(max(spam)))
        spam.pop(spam.index(min(spam)))

    return spam[0]


# ###########################################################################################################
#                                                                                                           #
# Вариант с использованием встроенного модуля                                                               #
#                                                                                                           #
# ###########################################################################################################
def get_median_builtin(array):
    return median(array)


# ###########################################################################################################
#                                                                                                           #
# Вариант с сортировкой                                                                                     #
#                                                                                                           #
# ###########################################################################################################
def shell_sort(arr):

    def get_increment(array):

        inc = [1, 4, 10, 23, 57, 132, 301, 701, 1750]

        while len(array) <= inc[-1]:
            inc.pop()

        while len(inc) > 0:
            yield inc.pop()

    for step in get_increment(arr):
        for i in range(step, len(arr)):
            for j in range(i, step - 1, -step):
                if arr[j - step] <= arr[j]:
                    break
                arr[j], arr[j - step] = arr[j - step], arr[j]

    return arr


def get_median_sort(array):

    # Для получения результата есть два варианта:
    # 1) для способа, на котором настаивает преподаватель, нужно сюда передавать m либо вместе с готовым массивом, либо
    # генерировать его в этой функции, но это либо просто глупо, либо приводит к необходимости создания отдельной
    # функции для генерации массива, чтобы не повторять код в каждой функции, за что уже было получено замечание
    # в первых уроках;
    # 2) выполнить задачу так, как выполнил кто-то из учеников, за что получил тоже замечание на разборе - дилемма!
    # Несмотря на это, учитывая ситуацию в выбранной структуре кода для выполнения ДЗ, выберу 2-ой вариант.
    return len(shell_sort(array)) // 2


if __name__ == '__main__':
    NUM = 10000
    m = -1
    tries = 3
    while tries > 0 >= m:
        tries -= 1
        try:
            m = int(input("Введите m (целое положительное число): "))
            if m <= 0:
                print(f"m должно быть >= 1, у вас осталось попыток: {tries}")
        except ValueError as ex:
            print(ex)
    size = 2 * m + 1

    a = [random() * 100 for _ in range(size)]
    print("Исходный массив:")
    print(a)
    print(f"Время нахождения функцией get_median_max_min: "
          f"{timeit('get_median_max_min(a[:])', number=NUM, globals=globals())}")
    print(f"Время нахождения функцией get_median_builtin: "
          f"{timeit('get_median_builtin(a[:])', number=NUM, globals=globals())}")
    print(f"Время нахождения функцией get_median_sort: "
          f"{timeit('get_median_sort(a[:])', number=NUM, globals=globals())}")

    """
    Введите m (целое положительное число): 100
    Исходный массив:
    [12.712271373823047, 4.640049947534575, 87.39446938966269, 3.885947711270854, ... 67.9667552143927]
    Время нахождения функцией get_median_max_min: 5.3977574
    Время нахождения функцией get_median_builtin: 0.13365270000000073
    Время нахождения функцией get_median_sort: 4.932391900000001
    
    Вывод: При достаточно большом размере массива функция с предварительной сортировкой оказвается более быстрой, чем
    простое исключение минимальных и максимальных элементов до получения результата. Встроенная функция, вполне ожидаемо
     и очевидно значительно превосходит два созданных.
    """
