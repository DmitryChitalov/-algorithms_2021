"""
3. Массив размером 2m + 1, где m – натуральное число, заполнен случайным образом.
Найдите в массиве медиану. Медианой называется элемент ряда, делящий его на
две равные по длине части: в одной находятся элементы, которые не меньше медианы,
в другой – не больше медианы.

Задачу можно решить без сортировки исходного массива.

Но если это слишком сложно, то используйте метод сортировки,
который не рассматривался на уроках: Шелла, Гномья, Кучей...

Важно: стройте массив именно по формуле 2m+1
Потому что параметр m вам пригодится при поиске медианы, когда массив будет отсортирован.
Этот парамет m вам нужно запрашивать у пользователя.

[5, 3, 4, 3, 3, 3, 3]

[3, 3, 3, 3, 3, 4, 5]

my_lst
new_lts

arr[m]


from statistics import median

[3, 4, 3, 3, 5, 3, 3]

left = []
right = []

left == right and

for i in
    for
    left == right
    left.clear()
    right.clear()


"""

from random import randint
from timeit import timeit

m = input('Введите натуральное число m: ')
while not m.isdigit() or not int(m):
    m = input('Некорректный ввод. Должно быть введено натуральное число.\nВведите число m: ')
m = int(m)
orig_list = [randint(-100, 100) for _ in range(2 * m + 1)]
ol_copy = orig_list[:]
print('Исходный массив:', orig_list)
print('Копия исходного массива:', ol_copy)

###################################### Heapsort ######################################
print('###################################### Heapsort ######################################')


def heapsort(lst):
    # Формируем сортирующее дерево. Делаем просейку для элементов с потомками.
    # Т.к. индексы левых и правых потомков элемнта с индесом i - 2i + 1 и 2i +2, идем с элемента len(lst) - 2
    for i in range((len(lst) - 2) // 2, -1, -1):
        clearing(lst, i, len(lst) - 1)

    for i in range(len(lst) - 1, 0, -1):  # В корне - максимум. Меняем с концом местами, формируем сортирующее дерево
        lst[i], lst[0] = lst[0], lst[i]  # для неотсортированной части.
        clearing(lst, 0, i - 1)


def clearing(lst, start, stop):
    root = start
    while 1:
        child = root * 2 + 1  # Левый потомок
        if child > stop:
            break

        if child + 1 <= stop and lst[child] < lst[child + 1]:
            child += 1

        if lst[root] < lst[child]:
            lst[root], lst[child] = lst[child], lst[root]
            root = child
        else:
            break


heapsort(ol_copy)

print('Отсортированная копия массива: ', ol_copy)
print('Медиана в нашем массиве: ', ol_copy[m])

###################################### Удаление максимумов ######################################
print('###################################### Удаление максимумов ######################################')


def func(lst):
    ol_copy = lst[:]

    while len(ol_copy) > m + 1:
        ol_copy.pop(ol_copy.index(max(ol_copy)))
    return ol_copy


print('Медиана в нашем массиве: ', max(func(orig_list)))

###################################### Замеры ######################################
print('###################################### Замеры ######################################')

print('Heapsort:')
print('Замеры 10.   ', timeit("heapsort(orig_list[:])", globals=globals(), number=10))
print('Замеры 100.  ', timeit("heapsort(orig_list[:])", globals=globals(), number=100))
print('Замеры 1000. ', timeit("heapsort(orig_list[:])", globals=globals(), number=1000))

print('Писк максимумов:')
print('Замеры 10.   ', timeit("func(orig_list[:])", globals=globals(), number=10))
print('Замеры 100.  ', timeit("func(orig_list[:])", globals=globals(), number=100))
print('Замеры 1000. ', timeit("func(orig_list[:])", globals=globals(), number=1000))

'''
Результаты замеров:
Введите натуральное число m: 5
Исходный массив: [-19, -91, 75, -52, -89, -2, -22, 17, 34, -36, 72]
Копия исходного массива: [-19, -91, 75, -52, -89, -2, -22, 17, 34, -36, 72]
###################################### Heapsort ######################################
Отсортированная копия массива:  [-91, -89, -52, -36, -22, -19, -2, 17, 34, 72, 75]
Медиана в нашем массиве:  -19
###################################### Удаление максимумов ######################################
Медиана в нашем массиве:  -19
###################################### Замеры ######################################
Heapsort:
Замеры 10.    0.00013390000000002011
Замеры 100.   0.001260599999999945
Замеры 1000.  0.01276389999999994
Писк максимумов:
Замеры 10.    3.2000000000032e-05
Замеры 100.   0.00026020000000004373
Замеры 1000.  0.0025697999999998444

Вывод:
Удаление максимумов показывает себя лучше, чем поиск медианы через сортировку.
'''
