"""
3. Массив размером 2m + 1, где m – натуральное число, заполнен случайным образом.
Найдите в массиве медиану. Медианой называется элемент ряда, делящий его на
две равные по длине части: в одной находятся элементы, которые не меньше медианы,
в другой – не больше медианы.

Задачу можно решить без сортировки исходного
массива.

Но если это слишком сложно, то используйте метод сортировки,
который не рассматривался на уроках: Шелла, Гномья, Кучей...

[5, 3, 4, 3, 3, 3, 3]

[3, 3, 3, 3, 3, 4, 5]

my_lst
new_lts

arr[m]


from statistics import median

[3, 4, 3, 3, 5, 3, 3]


left.clear()
right.clear()


m = 3
len = 7
i
left = []
right = []

left == right and

for i in
    for
    left == right
    left.clear()
    right.clear()


"""

from random import randint as rnd
from statistics import median
from timeit import timeit


# Быстрая сортировка, взял для наглядности
def fast_sort(ar):  # O(n log n)
    if len(ar) <= 1:
        return ar
    elem = ar[0]
    left = list(filter(lambda x: x < elem, ar))
    center = [i for i in ar if i == elem]
    right = list(filter(lambda x: x > elem, ar))

    return fast_sort(left) + center + fast_sort(right)


arr_fast = [rnd(1, 100) for _ in range(11)]
print(f'{"*" * 25} Быстрая сортировка {"*" * 25}')
print(f'Исходный список {arr_fast}\n'
      f'Отсортированный список {fast_sort(arr_fast)}')
print("Медиана Быстрая сортировка:", fast_sort(arr_fast)[(len(arr_fast) - 1) // 2]
if len(arr_fast) % 2 != 0 else f'Нужно только нечетная длина списка')
print(f'Медиана по встроенной фун-и: {median(arr_fast)}')


##########################################################################


# Сортировка Шелла
def shell(ar):  # O(n^2)
    last_index = len(ar) - 1
    step = len(ar) // 2
    while step > 0:
        for i in range(step, last_index + 1, 1):
            j = i
            delta = j - step
            while delta >= 0 and ar[delta] > ar[j]:
                ar[delta], ar[j] = ar[j], ar[delta]
                j = delta
                delta = j - step
        step //= 2
    return ar


arr_shel = [rnd(1, 100) for _ in range(11)]
print(f'{"*" * 25} Сортировка Шелла {"*" * 25}')
print(f'Исходный список {arr_shel}\n'
      f'Отсортированный список {shell(arr_shel)}')
print("Медиана Шелла:", shell(arr_shel)[(len(arr_shel) - 1) // 2]
if len(arr_shel) % 2 != 0 else f'Нужно только нечетная длина списка')
print(f'Медиана по встроенной фун-и: {median(arr_shel)}')


##########################################################################


# Сортировка "Кучей" или Пирамидальная сортировка
def heap(ar, size, ind):  # O(n log n)
    largest = ind
    left_child = (2 * ind) + 1
    right_child = (2 * ind) + 2
    if left_child < size and ar[left_child] > ar[largest]:
        largest = left_child

    if right_child < size and ar[right_child] > ar[largest]:
        largest = right_child

    if largest != ind:
        ar[ind], ar[largest] = ar[largest], ar[ind]
        heap(ar, size, largest)


def heap_sort(nums):
    n = len(nums)
    for i in range(n, -1, -1):
        heap(nums, n, i)
    for i in range(n - 1, 0, -1):
        nums[i], nums[0] = nums[0], nums[i]
        heap(nums, i, 0)
    return nums


arr_heap = [rnd(50, 100) for _ in range(11)]
print(f'{"*" * 25} Сортировка "Кучей" {"*" * 25}')
print(f'Исходный список {arr_heap}\n'
      f'Отсортированный список {heap_sort(arr_heap)}')
print("Медиана Кучи :", heap_sort(arr_heap)[(len(arr_heap) - 1) // 2]
if len(arr_heap) % 2 != 0 else f'Нужно только нечетная длина списка')
print(f'Медиана по встроенной фун-и: {median(arr_heap)}')


##########################################################################


# Гномья сортировка
def gnome_sort(ar):  # O(n^2)
    i, j, size = 1, 2, len(ar)
    while i < size:
        if ar[i - 1] <= ar[i]:
            i, j = j, j + 1
        else:
            ar[i - 1], ar[i] = ar[i], ar[i - 1]
            i -= 1
            if i == 0:
                i, j = j, j + 1
    return ar


arr_gnome = [rnd(50, 100) for _ in range(11)]
print(f'{"*" * 25} Гномья сортировка {"*" * 25}')
print(f'Исходный список {arr_gnome}\n'
      f'Отсортированный список {gnome_sort(arr_gnome)}')
print("Медиана Гномья :", gnome_sort(arr_gnome)[(len(arr_gnome) - 1) // 2]
if len(arr_gnome) % 2 != 0 else f'Нужно только нечетная длина списка')
print(f'Медиана по встроенной фун-и: {median(arr_gnome)}')


##########################################################################


# Без сортировки исходного массива
def median_max(ar):  # O(n^2)
    for i in range(len(ar) // 2):
        ar.remove(max(ar))

    return max(ar)


arr = [rnd(1, 100) for _ in range(11)]
print(f'{"*" * 17} Без сортировки исходного массива {"*" * 17}')
print(f'Исходный массив {arr}')
print(f'Медиана: {median_max(arr[:])}')
print(f'Медиана по встроенной фун-и: {median(arr)}')

##########################################################################

"""
************************* Быстрая сортировка *************************
Исходный список [71, 46, 36, 27, 97, 63, 18, 52, 16, 33, 27]
Отсортированный список [16, 18, 27, 27, 33, 36, 46, 52, 63, 71, 97]
Медиана Быстрая сортировка: 36
Медиана по встроенной фун-и: 36
************************* Сортировка Шелла *************************
Исходный список [25, 59, 1, 99, 41, 52, 84, 37, 60, 19, 57]
Отсортированный список [1, 19, 25, 37, 41, 52, 57, 59, 60, 84, 99]
Медиана Шелла: 52
Медиана по встроенной фун-и: 52
************************* Сортировка "Кучей" *************************
Исходный список [83, 88, 84, 51, 99, 69, 72, 57, 64, 66, 52]
Отсортированный список [51, 52, 57, 64, 66, 69, 72, 83, 84, 88, 99]
Медиана Кучи : 69
Медиана по встроенной фун-и: 69
************************* Гномья сортировка *************************
Исходный список [60, 59, 59, 56, 50, 70, 89, 61, 86, 81, 78]
Отсортированный список [50, 56, 59, 59, 60, 61, 70, 78, 81, 86, 89]
Медиана Гномья : 61
Медиана по встроенной фун-и: 61
***************** Без сортировки исходного массива *****************
Исходный массив [73, 81, 57, 50, 24, 79, 92, 14, 67, 80, 57]
Медиана: 67
Медиана по встроенной фун-и: 67
"""

# Замеры
if __name__ == '__main__':
    """
    Результаты замеров подтвердили теоретическую сложность всех алгоритмов, алгоритмы с квадратичной(O(n^2)),
    показали самый плохой результат, в особенности методом Гномье сортировки, без сортировки массива показала,
    хорошее время на малых объемах, но сростом данным время растет, в то время как алгоритмы линейно-логариф.(O(n log n))
    такой как сортировка Кучей, показывает лучшее время.
    Вопрос у меня возник только с алгоритмом Шелла, что в нем не так, что я не верно сделал, буду благодарен 
    если укажете на мои просчеты :)
    Для наглядности делал замеры быстрой сортировки (O(n log n)) линейно-логарифмическая сложность и строенной sorted
    в основе которой алгоритм Timsort где в лучшем случае сложность O(n) линейная.
    **** Замеры 101 *******
    Быстрая сортировка 1.5504249350000001
    Сортировка Шелла 0.84803797
    Сортировка "Кучей" 1.8807068090000003
    Сортировка "Гномья" 3.8994429630000003
    Без сортировки 0.6271338370000006
    Встроенная "sorted" 0.02672613200000029


    **** Замеры 1001 **********
    Быстрая сортировка 15.522571598999999
    Сортировка Шелла 14.304157816 <- КАК!?
    Сортировка "Кучей" 29.375802142999998
    Сортировка "Гномья" 460.55774610300006
    Без сортировки 59.265242133000015
    Встроенная "sorted" 0.7025036599999339
    """
    # замеры 101
    print(f'{"*" * 25} Замеры 101 {"*" * 25}')
    # для сокращения мат. операций решил вводить нечетное число списков руками
    # можно сделать так arr_101 = [rnd(-100, 100) for _ in range(2 * m + 1)]
    arr_101 = [rnd(-100, 100) for _ in range(101)]
    print(f'Быстрая сортировка {timeit("fast_sort(arr_101[:])", globals=globals(), number=10000)}')
    print(f'Сортировка Шелла {timeit("shell(arr_101[:])", globals=globals(), number=10000)}')
    print(f'Сортировка "Кучей" {timeit("heap_sort(arr_101[:])", globals=globals(), number=10000)}')
    print(f'Сортировка "Гномья" {timeit("gnome_sort(arr_101[:])", globals=globals(), number=10000)}')
    print(f'Без сортировки {timeit("median_max(arr_101[:])", globals=globals(), number=10000)}')
    print(f'Встроенная "sorted" {timeit("sorted(arr_101[:])", globals=globals(), number=10000)}')

    # замеры 1001
    print(f'{"*" * 25} Замеры 1001 {"*" * 25}')
    # для сокращения мат. операций решил вводить нечетное число списков руками
    # можно сделать так arr_101 = [rnd(-100, 100) for _ in range(2 * m + 1)]
    arr_1001 = [rnd(-100, 100) for _ in range(1001)]
    print(f'Быстрая сортировка {timeit("fast_sort(arr_1001[:])", globals=globals(), number=10000)}')
    print(f'Сортировка Шелла {timeit("shell(arr_1001[:])", globals=globals(), number=10000)}')
    print(f'Сортировка "Кучей" {timeit("heap_sort(arr_1001[:])", globals=globals(), number=10000)}')
    print(f'Сортировка "Гномья" {timeit("gnome_sort(arr_1001[:])", globals=globals(), number=10000)}')
    print(f'Без сортировки {timeit("median_max(arr_1001[:])", globals=globals(), number=10000)}')
    print(f'Встроенная "sorted" {timeit("sorted(arr_1001[:])", globals=globals(), number=10000)}')
