"""
2. Отсортируйте по возрастанию методом слияния одномерный вещественный массив,
заданный случайными числами на промежутке [0; 50). Выведите на экран исходный
и отсортированный массивы.

Хотя в примерах к уроку уже есть вариант реализации слияния,
попробуйте предложить другой (придумать или найти).

И попытаться сделать замеры на массивах разной длины: 10, 100, 1000, ...

Пример:
Введите число элементов: 5
Исходный - [46.11436617832828, 41.62921998361278, 18.45859540989644, 12.128870723745806, 8.025098788570562]
Отсортированный - [8.025098788570562, 12.128870723745806, 18.45859540989644, 41.62921998361278, 46.11436617832828]
"""

from random import random
from timeit import timeit

user_input = input('Введите число элементов: ')
while not user_input.isdigit() or not int(user_input):
    user_input = input('Некорректный ввод. Должно быть введено натуральное число.\nВведите число элементов: ')
orig_list = [random() * 50 for _ in range(int(user_input))]
ol_copy = orig_list[:]
print('Исходный массив:', orig_list)
print('Копия исходного массива:', ol_copy)


# Предполагаем, что a - это левый массив, а b - это правый. Будем также обеспечивать устойчивость сортировки.

def merge(a, b):
    c = [0] * (len(a) + len(b))
    i = k = n = 0
    while i < len(a) and k < len(b):
        if a[i] <= b[k]:  # Устойчивость соблюдена.
            c[n] = a[i]
            n += 1
            i += 1
        else:
            c[n] = b[k]
            n += 1
            k += 1
    while i < len(a):
        c[n] = a[i]
        n += 1
        i += 1

    while k < len(b):
        c[n] = b[k]
        n += 1
        k += 1
    return c


def merge_sort(lst):
    if len(lst) <= 1:
        return
    middle = len(lst) // 2
    left_side = [lst[i] for i in range(middle)]
    right_side = [lst[i] for i in range(middle, len(lst))]

    merge_sort(left_side)
    merge_sort(right_side)

    res = merge(left_side, right_side)
    lst[:] = res[:]


merge_sort(ol_copy)
print('Отсортированная копия массива: ', ol_copy)

###################################### Замеры ######################################
print('###################################### Замеры ######################################')

print('Замеры 10.   ', timeit("merge_sort(orig_list[:])", globals=globals(), number=10))
print('Замеры 100.  ', timeit("merge_sort(orig_list[:])", globals=globals(), number=100))
print('Замеры 1000. ', timeit("merge_sort(orig_list[:])", globals=globals(), number=1000))


'''
Результаты замеров:

Введите число элементов: 5
Исходный массив: [3.6780563359913367, 10.463055090832718, 38.915468067836116, 3.901127939864424, 11.610794108901946]
Копия исходного массива: [3.6780563359913367, 10.463055090832718, 38.915468067836116, 3.901127939864424, 11.610794108901946]
Отсортированная копия массива:  [3.6780563359913367, 3.901127939864424, 10.463055090832718, 11.610794108901946, 38.915468067836116]
###################################### Замеры ######################################
Замеры 10.    0.00011810000000012089
Замеры 100.   0.0010676000000000574
Замеры 1000.  0.010734999999999939

Вывод: Сортировка работает достаточно эффективно.
'''