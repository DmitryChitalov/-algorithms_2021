"""
2. Отсортируйте по возрастанию методом слияния одномерный вещественный массив,
заданный случайными числами на промежутке [0; 50). Выведите на экран исходный
и отсортированный массивы.

Хотя в примерах к уроку уже есть вариант реализации слияния,
попробуйте предложить другой (придумать или найти)

И попытаться сделать замеры на массивах разной длины: 10, 100, 1000, ...

Пример:
Введите число элементов: 5
Исходный - [46.11436617832828, 41.62921998361278, 18.45859540989644, 12.128870723745806, 8.025098788570562]
Отсортированный - [8.025098788570562, 12.128870723745806, 18.45859540989644, 41.62921998361278, 46.11436617832828]

**********************************************************

Для решения задачи используется иреративный вариант алгоритма
сортировки слиянием, при котором изначальный массив считается
разбитым на подмассивы по 1 элементу, которые сравниваются меджу собой,
затем по 2 элемента, по 4 элемента и т.д., пока не будет достигнут конец массива.

Итеративный алгоритм n = 10: 0.00030149999999998234 сек
Рекурсивный алгоритм n = 10: 0.00022039999999998172 сек

Итеративный алгоритм n = 100: 0.0337133 сек
Рекурсивный алгоритм n = 100: 0.030217999999999995 сек

Итеративный алгоритм n = 1000: 5.0077164 сек
Рекурсивный алгоритм n = 1000: 4.188505500000001 сек

Как видно из замеров, рекурсивный алгоритм имеет преимущество
по времени выполнения.
Теоретически, итеративный алгоритм должен иметь преимущество
по используемой памяти за счёт отсутствия стека вызовов, но
доказать это замерами не удалось - профилировщик
показывает аналогичные значения.
"""
from random import random
from timeit import timeit


def merge_iterative(array):
    # задаём длину подмассивов для сортировки
    sub_len = 1
    # пока не будет отсортирован весь массив
    while sub_len < len(array):
        # левый край соединяемых подмассивов
        left = 0
        while left < len(array) - 1:
            # правый край соединяемых подмассивов
            # (меньшее из двух: левый край + две длины подмассива или конец массива)
            right = min(left + 2 * sub_len, len(array))
            # граница между подмассивами (левый край + длина подмассива или конец массива)
            mid = min(left + sub_len, len(array))

            # создаём/обнуляем временный массив для хранения
            # отсортированного подмассива
            temp = []

            # выставляем указатели на нулевые индексы подмассивов
            item1 = item2 = 0

            # Пока индекс левого элемента меньше индекса
            # конечного элемента первой половины массива,
            # или индекс второго элемента меньше конечного индекса
            # второй половины массива, складываем меньший элемент
            # во временный массив и сдвигаем индекс
            while left + item1 < mid and mid + item2 < right:
                if array[left + item1] <= array[mid + item2]:
                    temp.append(array[left + item1])
                    item1 += 1
                else:
                    temp.append(array[mid + item2])
                    item2 += 1

            # когда один из подмассивов закончился,
            # переносим оставшиеся элементы из другого в конец
            # временного массива
            while left + item1 < mid:
                temp.append(array[left + item1])
                item1 += 1
            while mid + item2 < right:
                temp.append(array[mid + item2])
                item2 += 1

            # переносим элементы из временного массива в сортируемый
            array[left:left + item1 + item2] = temp

            # переходим к следующемо подмассиву
            left += 2 * sub_len

        # увеличиваем длину подмассива
        sub_len *= 2

    return array


# код с урока для сравнения
def merge_sort(lst_obj):
    if len(lst_obj) > 1:
        center = len(lst_obj) // 2
        left = lst_obj[:center]
        right = lst_obj[center:]

        merge_sort(left)
        merge_sort(right)

        i, j, k = 0, 0, 0

        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                lst_obj[k] = left[i]
                i += 1
            else:
                lst_obj[k] = right[j]
                j += 1
            k += 1

        while i < len(left):
            lst_obj[k] = left[i]
            i += 1
            k += 1

        while j < len(right):
            lst_obj[k] = right[j]
            j += 1
            k += 1
        return lst_obj


test_list = [random() * 50 for _ in range(5)]
print(f'Исходный массив: {test_list}')
print(f'Отсортированный массив: {merge_iterative(test_list[:])}')
print()

test_list = [random() * 50 for _ in range(10)]
print(f'Итеративный алгоритм n = 10: '
      f'{timeit("merge_iterative(test_list[:])", globals=globals(), number=10)} сек')
print(f'Рекурсивный алгоритм n = 10: '
      f'{timeit("merge_sort(test_list[:])", globals=globals(), number=10)} сек')
print()

test_list = [random() * 50 for _ in range(100)]
print(f'Итеративный алгоритм n = 100: '
      f'{timeit("merge_iterative(test_list[:])", globals=globals(), number=100)} сек')
print(f'Рекурсивный алгоритм n = 100: '
      f'{timeit("merge_sort(test_list[:])", globals=globals(), number=100)} сек')
print()

test_list = [random() * 50 for _ in range(1000)]
print(f'Итеративный алгоритм n = 1000: '
      f'{timeit("merge_iterative(test_list[:])", globals=globals(), number=1000)} сек')
print(f'Рекурсивный алгоритм n = 1000: '
      f'{timeit("merge_sort(test_list[:])", globals=globals(), number=1000)} сек')
