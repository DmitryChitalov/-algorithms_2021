"""
Задание 1.
Реализуйте свои пользовательские функции, в которых реализуйте:
a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""
import time


def time_measure(func):  # декоратор для замеров времени
    def wrap(*args):
        time_start = time.time()
        func(*args)
        time_end = time.time()
        print(f'Время выполнения функции {func.__name__}: {time_end - time_start}.')
        return func

    return wrap()


@time_measure
def list_generator():  # заполнение списка. Сложность O(n)
    my_list_1 = [num for num in range(0, 100000)]
    return my_list_1


@time_measure
def dict_generator():
    my_dict_1 = {num: num ** 2 for num in range(0, 100000)}  # заполнение словаря. Сложность O(2n)
    return my_dict_1


# заполнение списка происходит быстрее, т.к. при заполнении словаря дополнительно производятся вычисления для получения
# значений

my_list = list(range(0, 1000000))
my_dict = {a: a ** 2 for a in range(1000000)}


# сохранение элемента, всавка элемента, удаоение элемента, получение элемента
@time_measure
def list_oper_el():
    my_list[99999] = 'Новое значение'  # сложность O(n)
    del my_list[99999]  # сложность O(n)
    return my_list[99998]  # сложность O(1)


@time_measure
def dict_oper_el():  # сложность O(1)
    my_dict[99999] = 'Новое значение'  # сложность O(1)
    del my_dict[99999]  # сложность O(1)
    return my_dict[99998]
# У операций словаря в примерах сложность константная, а у списка, в основном - линейная.
# Операции со словарём выполняются быстрее
