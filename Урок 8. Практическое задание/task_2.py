"""
Задание 2.

Доработайте пример структуры "дерево",
рассмотренный на уроке.

Предложите варианты доработки и оптимизации
(например, валидация значений узлов в соответствии с требованиями для бинарного дерева).

Поработайте с доработанной структурой, позапускайте на реальных данных - на клиентском коде.
"""

class OwnError(Exception):
    def __init__(self, text):
        self.text = text


class BinaryTree:
    def __init__(self, root_obj, anc=0, pos=None):
        #ссылка на предка
        self.anc = anc
        #позиция в которую поставили элемент бинерного дерева (право/лево
        self.pos = pos
        #корень
        self.root = root_obj
        # левый потомок
        self.left_child = None
        # правый потомок
        self.right_child = None

    # добавить левого потомка
    def insert_left(self, new_node):
        # ссылка на предка. Понимаю, что это выглядит как костыль, другой реализации не придумал.
        anc = self
        #Так как функция insert_left, то указываем позицию элемента left
        pos = 'left'
        try:
            #если левый потомок уже существует, то мы сразу поднимаем ошибку.
            if self.left_child:
                raise OwnError('Этот потомок уже существует, нельзя поменять его')
            if self.pos != 'right' and new_node < self.root:
                self.left_child = BinaryTree(new_node, anc, pos)
            elif self.pos != 'left' and new_node < self.root and new_node > self.anc.get_root_val():
                self.left_child = BinaryTree(new_node, anc, pos)
            else:
                raise OwnError("Этот элемент не может быть левым потомком, так как нарушена логика бинарного дерева")
        except OwnError as err:
            print(err)

    # добавить правого потомка
    def insert_right(self, new_node):
        anc = self
        pos = 'right'
        try:
            # если правый потомок уже существует, то мы сразу поднимаем ошибку.
            if self.right_child:
                raise OwnError('Этот потомок уже существует, нельзя поменять его')
            if self.pos != 'left' and new_node > self.root:
                self.right_child = BinaryTree(new_node, anc, pos)
            elif self.pos != 'right' and new_node > self.root and new_node < self.anc.get_root_val():
                self.right_child = BinaryTree(new_node, anc, pos)
            else:
                raise OwnError("Этот элемент не может быть правым потомком, так как нарушена логика бинарного дерева")
        except OwnError as err:
            print(err)


    # метод доступа к правому потомку
    def get_right_child(self):
        return self.right_child

    # метод доступа к левому потомку
    def get_left_child(self):
        return self.left_child

    # метод доступа к корню
    def get_root_val(self):
        return self.root


r = BinaryTree(8)
print(r.get_root_val())

print('-' * 30)

r.insert_left(4)
print(r.get_left_child())
r.insert_left(4) # поднимается ошибка о существовании элемента

print('-' * 30)

r.insert_right(16)
print(r.get_right_child())
r.insert_right(16) # поднимается ошибка о существовании элемента

print('-' * 30)

r.get_left_child().insert_right(10) # поднимается ошибка о нарушении логики
r.get_left_child().insert_right(7)  # все работает исправно
r.get_left_child().insert_left(7)   # поднимается ошибка о нарушении логики
r.get_left_child().insert_left(3)   # все работает исправно

print('-' * 30)

r.get_right_child().insert_right(10)  # поднимается ошибка о нарушении логики
r.get_right_child().insert_right(20)  # все работает исправно
print(r.get_right_child().get_right_child()) # показывает, что это всеразные объекты
r.get_right_child().insert_left(7)    # поднимается ошибка о нарушении логики
r.get_right_child().insert_left(10)   # все работает исправно



"""
О логике реализации функций:
Я убрал возможность изменять уже существующие элементы, так как если бы было создано большое дерево и кому-нибудь 
захотелось бы изменить начальные элементы это могло бы повлечь за собой необходимость изменения всего дерева.
Логика бинарного дерева заключается в том, что элементы больше корневого должны находится от него в левой части, 
меньше - в правой. 
Здесь я прописываю такую логику: Если мы вставляем потомка вправо, то сначала надо посмотреть в какой позиции корневой 
элемент. Допустим такое дерево:
      8
   4    16
Если корневой элемент (16) стоит в правой позиции, то все что нам надо проверить, это чтобы потомок (допустим 20) 
был больше корневого элемента (16). Но если же он стоит в левой позиции (4), то надо учитывает чтобы 
потомок (допустим 7) был одновременно больше корневого элемента(4), но меньше предка корневого элемента(8). Получается: 
          8
      4       16
        7        20
Если же мы вставляем элемент влево, то все аналогично. Мы должны проверить в какой позиции стоит корневой элемент.
Если корневой элемент (4) стоит в позиции лево, то потомок(допустим 3) просто должен быть меньше корневого элемента(4).
Если же корневой элемент стоит на позиции право(16), то потомок (допустим 10), должен быть одновременно меньше 
корневого элемента, но больше его предка(8). Получается:
           8
    4             16
  3    7       10    20
Все это равносильно и для более больших деревьев. Проверять нам надо только предыдущего предка, а не все дерево целиком,
так как создавая большое дерево, мы постепенно и так все проверяли.

Используем не равно в функиях (инверсию грубо говоря), чтобы не прописывать отдельный случай для только что 
созданного дерева, когда его корень, не стоит ни в позиции лево ни в позиции право
"""
