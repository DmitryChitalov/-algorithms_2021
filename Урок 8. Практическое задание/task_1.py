"""
Задание 1.
Реализуйте кодирование строки "по Хаффману".
У вас два пути:
1) тема идет тяжело? тогда вы можете, опираясь на пример с урока, сделать свою!!! версию алгоритма
Разрешается и приветствуется изменение имен переменных, выбор других коллекций, различные изменения
и оптимизации.

2) тема понятна? постарайтесь сделать свою реализацию.
Вы можете реализовать задачу, например, через ООП или предложить иной подход к решению.
"""
from collections import Counter
from pprint import pprint

STRING = 'мама мыла раму'


# STRING = 'курбангулы бердымухамедов у тенирбергена бердонгарова украл кораллы,'\
#     'а тенирберген бердонгаров у курбангулы бердымухамедова украл кларнет'

class Node():
    def __init__(self, w, c=None, a=None, b=None):
        self.objA, self.objB = a, b
        self.weight, self.char = w, c

    def get_weight(self):
        return self.weight


def prepare_zip(src):
    out_dict = dict()
    def return_zip(btree: Node, symb=''):
        if btree.objA and btree.objB:
            return_zip(btree.objA, symb + '0', )
            return_zip(btree.objB, symb + '1')
        else:
            out_dict[btree.char] = symb[1:]
        return out_dict

    s = Counter(src)
    l = [Node(v, k) for k, v in s.items()]
    while len(l) > 1:
        l.sort(key=Node.get_weight)
        o1, o2 = l.pop(0), l.pop(0)
        n = Node(w=o1.weight + o2.weight,
                 a=o1, b=o2)
        l.append(n)
    return return_zip(l[0])


if __name__ == '__main__':
    print(STRING)
    pprint(prepare_zip(STRING))
    exit(0)

'''
Выводы:
1. частотность можно эффективно использовать для оптимизации данных методом сжатия.
2. метод работает если в последовательности присутствуют повторяющиеся элементы
для выборки 10000 случайных числе из диапазона 0..10млн работать не будет.
3. потребовались костыли. лишний символ в конце удалил срезом symb[1:].
4. код не чистый, надо было спрятать словарь внутрь функции return_zip. позднее переделаю 3 и 4.
чтобы хаффману неповадно было.
5. попробовал решить самостоятельно руководствовался только картинками и описанием алгоритма.
6. проверил на фразе длинной. получилось 19 уникальных элементов, что выходит за рамки 4 битов, 
поэтому у нас 5 битов, следовательно алгоритм работает верно.


мама мыла раму
{' ': '10', 'а': '0', 'л': '111', 'м': '1', 'р': '00', 'у': '01', 'ы': '110'}


курбангулы бердымухамедов у тенирбергена бердонгарова украл кораллы,
а тенирберген бердонгаров у курбангулы бердымухамедова украл кларнет
{' ': '111',
 ',': '11000',
 'а': '01',
 'б': '111',
 'в': '0110',
 'г': '1100',
 'д': '1101',
 'е': '00',
 'и': '10100',
 'к': '1011',
 'л': '100',
 'м': '1101',
 'н': '010',
 'о': '101',
 'р': '00',
 'т': '10101',
 'у': '100',
 'х': '11001',
 'ы': '0111'}
 
 '''
