"""
Задание 1.
Реализуйте кодирование строки "по Хаффману".
У вас два пути:
1) тема идет тяжело? тогда вы можете, опираясь на пример с урока, сделать свою!!! версию алгоритма
Разрешается и приветствуется изменение имен переменных, выбор других коллекций, различные изменения
и оптимизации.

2) тема понятна? постарайтесь сделать свою реализацию.
Вы можете реализовать задачу, например, через ООП или предложить иной подход к решению.
"""
import sys
from collections import Counter
from pprint import pprint

# STRING = 'beep boop beer!'


STRING = 'курбангулы бердымухамедов у тенирбергена бердонгарова украл кораллы,'\
    'а тенирберген бердонгаров у курбангулы бердымухамедова украл кларнет'

class Node:
    def __init__(self, w, c=None, a=None, b=None):
        self.objA, self.objB = a, b
        self.weight, self.char = w, c

    def __str__(self):
        return f'(W{self.weight}, C{self.char}, A{self.objA}, B{self.objB})'

    def __repr__(self):
        return f'({self.char}{self.weight})'

    def get_weight(self):
        return self.weight


def prepare_zip(src):
    out_dict = dict()

    def return_zip(btree: Node, symb=''):
        if btree.objA or btree.objB:
            return_zip(btree.objA, symb + '0', )
            return_zip(btree.objB, symb + '1')
        else:
            out_dict[btree.char] = symb
        return out_dict

    s = Counter(src)
    l = [Node(v, k) for k, v in s.items()]
    while len(l) > 1:
        l.sort(key=Node.get_weight)
        o1, o2 = l.pop(0), l.pop(0)
        n = Node(w=o1.weight + o2.weight,
                 a=o1, b=o2)
        l.append(n)

    return return_zip(l[0])


def zip_string(s, dd: dict) -> str:
    return ''.join([dd[x] for x in s])


def unzip_string(z, dd: dict) -> str:
    tmp = ''
    while z:
        for k, v in d.items():
            if z.startswith(v):
                tmp += k
                z = z[len(v):]
                # print(tmp, z)
    return tmp


if __name__ == '__main__':
    print(STRING.__repr__())
    d = prepare_zip(STRING)
    pprint(d)
    zipped = zip_string(STRING, d)
    zipped_measure = int(zipped,2)
    print('getsizeof исходной строки', sys.getsizeof(STRING))
    print('Количество бит сжатой строки', sys.getsizeof(zipped), 'количество байт', len(zipped)//8)
    unzipped = unzip_string(zipped, d)
    print(unzipped)
    exit(0)

'''
Выводы:
1. частотность можно эффективно использовать для оптимизации данных методом сжатия.
2. метод работает если в последовательности присутствуют повторяющиеся элементы
для выборки 10000 случайных числе из диапазона 0..10млн работать не будет.
3. код не чистый, надо было спрятать словарь внутрь функции return_zip. позднее переделаю
чтобы хаффману неповадно было.
4. попробовал решить самостоятельно руководствовался только картинками и описанием алгоритма.
5. проверил на фразе длинной. получилось 19 уникальных элементов.
6. симулировал закодированную последовательность и раскодировал её используя словарь.
АЛГОРИТМ РАБОТАЕТ ВЕРНО))) и на длинной строке)))))))))))))
7. на длинной строке сжатие весьма эффективно (перевел в битовое выражение).
getsizeof исходной строки 346
Количество бит сжатой строки 597 количество байт 68


'beep boop beer!'
{' ': '101',
 '!': '1111',
 'b': '00',
 'e': '01',
 'o': '110',
 'p': '100',
 'r': '1110'}

0001011001010011011010010100010111101111
b 01011001010011011010010100010111101111
be 011001010011011010010100010111101111
bee 1001010011011010010100010111101111
beep 1010011011010010100010111101111
beep  0011011010010100010111101111
beep b 11011010010100010111101111
beep bo 11010010100010111101111
beep boo 10010100010111101111
beep boop 10100010111101111
beep boop  00010111101111
beep boop b 010111101111
beep boop be 0111101111
beep boop bee 11101111
beep boop beer 1111
beep boop beer! 
beep boop beer!



'курбангулы бердымухамедов у тенирбергена бердонгарова украл кораллы,
а тенирберген бердонгаров у курбангулы бердымухамедова украл кларнет'
{' ': '1111',
 ',': '011000',
 'а': '001',
 'б': '0111',
 'в': '10110',
 'г': '11100',
 'д': '11101',
 'е': '000',
 'и': '110100',
 'к': '11011',
 'л': '0100',
 'м': '01101',
 'н': '1010',
 'о': '0101',
 'р': '100',
 'т': '110101',
 'у': '1100',
 'х': '011001',
 'ы': '10111'}
getsizeof исходной строки 346
Количество бит сжатой строки 597 количество байт 68
курбангулы бердымухамедов у тенирбергена бердонгарова украл кораллы,
а тенирберген бердонгаров у курбангулы бердымухамедова украл кларнет
 '''
