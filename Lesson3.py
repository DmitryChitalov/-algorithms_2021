"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря программно,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!
"""
import time

start = time.time()
dict_1 = {k: k**2 for k in range(1, 1000 + 1)}
end = time.time()
ping = end - start
print(dict_1, ping)
print()

# Временная сложность поиска ключа словаря равна O(1) константаная,
# поскольку они существуют в виде hash-таблиц.


start_2 = time.time()
list_1 = [v for v in range(1, 1000 + 1)]
end_2 = time.time()
ping_2 = end_2 - start_2
print(list_1, ping_2)

# Временная сложность поиска в списке составляет O(n).
# Тоесть с количесвтом входных данных, пропорционально возрастает нагрузка.


"""
Задание 2.
Ваша программа должна запрашивать пароль
Для этого пароля вам нужно получить хеш, используя функцию sha256
Для генерации хеша обязательно нужно использовать криптографическую соль
Обязательно выведите созданный хеш

Далее программа должна запросить пароль повторно
Вам нужно проверить, совпадает ли пароль с исходным
Для проверки необходимо сравнить хеши паролей

ПРИМЕР:
Введите пароль: 123
В базе данных хранится строка: 555a3581d37993843efd4eba1921f1dcaeeafeb855965535d77c55782349444b
Введите пароль еще раз для проверки: 123
Вы ввели правильный пароль

Допускаются любые усложения задания - валидация, подключение к БД, передача данных в файл
"""
# sqlite, postgres, db_api, orm

import hashlib


def account():
    accounts = {}
    log = input('Введите логин: ')
    pas = input('Введите пароль: ')
    tem = hashlib.sha256(log.encode() + pas.encode()).hexdigest()
    print(f'Хеш пароля: {tem}')
    accounts[log] = tem
    print(accounts)
    log_try = input('Повторите логин: ')
    pas_try = input('Повторите пароль: ')

    while True:
        tem_try = hashlib.sha256(log_try.encode() + pas_try.encode()).hexdigest()
        if tem_try != tem:
            try:
                print('Логин или пароль не верны! Повторите попытку!')
                log_try = input('Повторите логин: ')
                pas_try = input('Повторите пароль: ')
            except 'Логин или пароль не верны! Повторите попытку!':
                print('Ошибка')
        else:
            print('Добро пожаловать!')
            break


account()

"""
Задание 3.
Определить количество различных (уникальных) подстрок с использованием хеш-функции.
Дана строка S длиной N, состоящая только из строчных латинских букв.

Подсказка: примените вычисление хешей для подстрок с помощью хеш-функций и множества

Пример:
рара - 6 уникальных подстрок

рар
ра
ар
ара
р
а
"""

# hash?
hash_1 = set()
word = 'Wrath'
for i in range(len(word)):
    for j in range(i + 1, len(word) + 1):
        if word[i:j] != word:
            hash_1.add(hashlib.sha256(word[i:j].encode()).hexdigest())
            print(word[i:j])

"""
Задание 4.
Реализуйте скрипт "Кэширование веб-страниц"

Функция должна принимать url-адрес и проверять
есть ли в кэше соответствующая страница, если нет, то вносит ее в кэш

Подсказка: задачу решите обязательно с применением 'соленого' хеширования и хеш-таблиц
Можете условжнить задачу, реализовав ее через ООП
Не забудьте, что кэширование - механизм, а хеш-таблица - средство его реализации
"""



