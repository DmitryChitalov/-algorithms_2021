"""
Задание 3.

Приведен код, формирующий из введенного числа
обратное по порядку входящих в него
цифр и вывести на экран.

Сделайте профилировку каждого алгоритма через cProfile и через timeit

Обязательно предложите еще свой вариант решения и также запрофилируйте!

Сделайте вывод, какая из четырех реализаций эффективнее и почему!!!

Без аналитики задание считается не принятым
"""
from timeit import timeit
from cProfile import run

num1 = 1234567890


def revers_1(enter_num, revers_num=0):
    if enter_num == 0:
        return revers_num
    else:
        num = enter_num % 10
        revers_num = (revers_num + num / 10) * 10
        enter_num //= 10
        return revers_1(enter_num, revers_num)


def revers_2(enter_num, revers_num=0):
    while enter_num != 0:
        num = enter_num % 10
        revers_num = (revers_num + num / 10) * 10
        enter_num //= 10
    return revers_num


def revers_3(enter_num):
    enter_num = str(enter_num)
    revers_num = enter_num[::-1]
    return revers_num


def revers_4(enter_num):
    k = []
    for i in (str(enter_num)):
        k.insert(0, i)
    return ''.join(k)


#print(timeit("revers_1(num1)",setup='from __main__ import revers_1, num1',number=10000))
## от 0.0178846 до 0.01835
#print(timeit("revers_2(num1)",setup='from __main__ import revers_2, num1',number=10000))
## от 0.0111131 до 0.0120364
#print(timeit("revers_3(num1)",setup='from __main__ import revers_3, num1',number=10000))
## 0.002514 до 0.002867
#print(timeit("revers_4(num1)",setup='from __main__ import revers_4, num1',number=10000))
## 0.008197 до 0.008884
"""
При стравнении результатов, полученных после тестирований функций модулем timeit, при значении повтора вызова
функций 10 000 раз, средние результаты следующие:
1. На первом месте решение встроенной функцией (revers_3) срезов для строки [::-1] c 0.002867.
2. Далее функция использующая списки и вставку по нулевому индексу (revers_4) с 0.008884.
3. На 3 месте функция, использующая цикл (revers_2) с 0.012036.
4. На последнем месте функция, использующая рекурсию (revers_1) с 0.01835.
"""


def main():
    num1 = 1234567890
    for i in range(10000):
        revers_1(num1)
        revers_2(num1)
        revers_3(num1)
        revers_4(num1)


run('main()')
"""
При стравнении результатов, полученных после тестирований функций модулем timeit, при значении повтора вызова
функций 10 000 раз, средние результаты следующие:
110000/10000    0.035    0.000    0.035    0.000 task_3.py:22(revers_1)
10000    0.012    0.000    0.012    0.000 task_3.py:32(revers_2)
10000    0.003    0.000    0.003    0.000 task_3.py:40(revers_3)
10000    0.016    0.000    0.026    0.000 task_3.py:46(revers_4)
По данным из cProfile увидеть, что функция (revers_1) на каждый свой вызов для обработки вызывает себя еще 10 раз,
из-за этого общая сумма вызовов равняется 110 000, время выполнения 0.035 сек.
Время выполнения функции (revers_2) 0.012 сек. 
Время выполнения функции (revers_3) 0.003 сек. 
Время выполнения функции (revers_4) 0.016 сек. 
Время выполнения функции revers_4 увеличилось в сравнении с тестами из timeit, из за того что обзщая сложность функции
из линейной стала квадратичной.
ВЫВОД: 
1. встроенный метод python для разворота строки в обратном порядке (str()[::-1]),является самой быстрой в обоих 
тестах как и все встроенные функции.
2. Функция, использующая рекурсию, является самой медленной, и проигрывает во времени функции, использующей цикл.

"""
