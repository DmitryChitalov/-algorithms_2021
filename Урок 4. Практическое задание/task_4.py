"""
Задание 4.

Приведены два алгоритма. В них определяется число,
которое встречается в массиве чаще всего.

Сделайте профилировку каждого алгоритма через timeit

Попытайтесь написать третью версию, которая будет самой быстрой и по возможности самой лаконичной.
Сделайте замеры и опишите, получилось ли у вас ускорить задачу.

Без аналитики задание считается не принятым!
"""

from timeit import repeat, default_timer


array = [1, 3, 1, 3, 4, 5, 1]


def func_1():
    m = 0
    num = 0
    for i in array:
        count = array.count(i)
        if count > m:
            m = count
            num = i
    return [num, m]


def func_2():
    new_array = []
    for el in array:
        count2 = array.count(el)
        new_array.append(count2)
    max_2 = max(new_array)
    elem = array[new_array.index(max_2)]
    return [elem, max_2]


""" Мои варианты решения задачи 
Выводы написаны ниже"""


# 1.1 Цикл for + set()
def func_3():
    max_val = [0, 0]
    for i in set(array):
        count_i = array.count(i)
        if count_i > max_val[1]:
            max_val = [i, count_i]
    return max_val


# 1.2 Генератор + set()
def func_3_gen():
    gen = (i for i in set(array))
    max_val = [0, 0]
    gen_val = 0
    while gen:
        gen_val = next(gen)
        count_i = array.count(gen_val)
        if count_i > max_val[1]:
            max_val = [gen_val, count_i]
        return max_val


# ---- Делаем замеры:
n = 10000

# Варианты из условия задачи:
f1 = repeat('func_1()', 'from __main__ import func_1', default_timer, 3, n)
f2 = repeat('func_2()', 'from __main__ import func_2', default_timer, 3, n)
# Добавленные решения
f3 = repeat('func_3()', 'from __main__ import func_3', default_timer, 3, n)
f3_gen = repeat('func_3_gen()', 'from __main__ import func_3_gen', default_timer, 3, n)


# ---- Выводим результаты:
label_res = ['func_1 - for по всем (баз.):',
             'func_2 - for + append() + max() (баз.):',
             'func_3 - for + set():',
             'func_3_gen - gen + set():']
results_time = [f1, f2, f3, f3_gen]
result_val = [func_1(), func_2(), func_3(), func_3_gen()]
all_res = zip(label_res, results_time, result_val)

print('Количесто замеров:', n)
print(f'{"Функция":^40.40} {"Результат"}   {"Мин.":20.20} {"Мин. - Макс."}\n{"-"*100}')

for row in all_res:
    print(f'{row[0]:40.40}  {row[2]} - {round(min(row[1]), 5)} - >>> {list(map(lambda x: round(x, 5), sorted(row[1])))}')

"""
Вывод:
Получилось сделать 2 варианта, который работают быстрее базовых условий.
Базовые варианты func_1 и func_2 делают избыточные операции в результате прохода по всему списку - т.е.
максимум уже найден, а цикл продолжается до конца.
В созданных функциях func_3 и func_3_gen алгоритм работает с использованием множества, 
что позволяется отсечь избыточные операции по поиску и подсчету количества значений в списке.
Оба вариант быстрее базовых. Вариант с генератором самый быстрый.  

Подробные результаты представлены ниже:


Результаты замеров:
Количесто замеров: 10000
                Функция                  Результат   Мин.                 Мин. - Макс.
----------------------------------------------------------------------------------------------------
func_1 - for по всем (баз.):              [1, 3] - 0.01213 - >>> [0.01213, 0.01254, 0.0161]
func_2 - for + append() + max() (баз.):   [1, 3] - 0.01387 - >>> [0.01387, 0.01453, 0.01675]
func_3 - for + set():                     [1, 3] - 0.00944 - >>> [0.00944, 0.01047, 0.01178]
func_3_gen - gen + set():                 [1, 3] - 0.00772 - >>> [0.00772, 0.00857, 0.00959]



Количесто замеров: 20000
                Функция                  Результат   Мин.                 Мин. - Макс.
----------------------------------------------------------------------------------------------------
func_1 - for по всем (баз.):              [1, 3] - 0.0196 - >>> [0.0196, 0.0212, 0.02398]
func_2 - for + append() + max() (баз.):   [1, 3] - 0.03066 - >>> [0.03066, 0.03093, 0.03211]
func_3 - for + set():                     [1, 3] - 0.01768 - >>> [0.01768, 0.01978, 0.02105]
func_3_gen - gen + set():                 [1, 3] - 0.01706 - >>> [0.01706, 0.01714, 0.01782]


Количесто замеров: 50000
                Функция                  Результат   Мин.                 Мин. - Макс.
----------------------------------------------------------------------------------------------------
func_1 - for по всем (баз.):              [1, 3] - 0.0763 - >>> [0.0763, 0.09326, 0.0999]
func_2 - for + append() + max() (баз.):   [1, 3] - 0.09733 - >>> [0.09733, 0.10183, 0.12125]
func_3 - for + set():                     [1, 3] - 0.06638 - >>> [0.06638, 0.06731, 0.06927]
func_3_gen - gen + set():                 [1, 3] - 0.05013 - >>> [0.05013, 0.05564, 0.06269]


Количесто замеров: 100000
                Функция                  Результат   Мин.                 Мин. - Макс.
----------------------------------------------------------------------------------------------------
func_1 - for по всем (баз.):              [1, 3] - 0.10529 - >>> [0.10529, 0.11932, 0.11936]
func_2 - for + append() + max() (баз.):   [1, 3] - 0.13437 - >>> [0.13437, 0.14881, 0.16457]
func_3 - for + set():                     [1, 3] - 0.08772 - >>> [0.08772, 0.09329, 0.1114]
func_3_gen - gen + set():                 [1, 3] - 0.07907 - >>> [0.07907, 0.08101, 0.08234]


"""








