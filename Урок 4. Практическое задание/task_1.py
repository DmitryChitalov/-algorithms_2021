"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Оптимизируйте, чтобы снизить время выполнения
Проведите повторные замеры.

Добавьте аналитику: что вы сделали и почему!!!
Без аналитики задание не принимается

И прошу вас обратить внимание, что то, что часто ошибочно называют генераторами списков,
на самом деле к генераторам отношения не имеет. Это называется "списковое включение" - list comprehension.
"""
from timeit import timeit
import random

LST = [int(random.randrange(0, 1000)) for el in range(10000)]
# print(LST)


# В работе со списками функция имеет сложность О(n) - скорость выполнения 0.06313260000000001
def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


# Немного оптимизировал за счет использования встроенной функции (здесь уже не создается range и не считается len).
# Время стало сопоставимым со временем использования спискового включения - 0.05755950000000001 (чуть быстрее).
# Причина большей скорости, видимо, в том, что встроенная функция сразу получает элемент с индексом
# и его не приходится искать отдельно - возможно функция преобразует данные в подобие словаря?
# При уыеличении длинны исходного списка до 10 000  ситуация не менялась.
def func_1_1(nums):
    new_arr = []
    for i, el in enumerate(nums):
        if el % 2 == 0:
            new_arr.append(i)
    return new_arr


# Увеличил скорость выполнения операции за счет спискового включения - скорость выполнения 0.05744690000000001
# Учитывая скорость выполнения и лаконичность, этот код предпочтительнее.
# Заметил на маленьких данных, что скорость выполнения иногда может оказываться больше первого варианта
def func_2(nums):
    result = [i for i, el in enumerate(nums) if el % 2 == 0]
    return result


def get_time(func):
    print(timeit(f'{func}', globals=globals(), number=1000000))
    

lst = [func_1(LST), func_1_1(LST), func_2(LST)]
for el in lst:
    get_time(el)

# get_time(func_1(LST))
# get_time(func_1_1(LST))
# get_time(func_2(LST))
