"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Оптимизируйте, чтобы снизить время выполнения
Проведите повторные замеры.

Добавьте аналитику: что вы сделали и почему!!!
Без аналитики задание не принимается

И прошу вас обратить внимание, что то, что часто ошибочно называют генераторами списков,
на самом деле к генераторам отношения не имеет. Это называется "списковое включение" - list comprehension.
"""
import timeit
first_arr = [num for num in range(1000)]


def func_1(nums):  # O(n) Линейная сложность
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


def func_2(nums):  # O(n) Линейная сложность
    new_arr = [n for n in nums if n % 2 == 0]
    return new_arr


def func_3(nums):  # O(n) Линейная сложность.
    new_arr = []
    for i in nums:
        new_arr.append(i)
    return new_arr


print(f"func_1: {timeit.timeit('func_1(first_arr)', globals=globals(), number=1000)}")
print(f"func_2: {timeit.timeit('func_2(first_arr)', globals=globals(), number=1000)}")
print(f"func_3: {timeit.timeit('func_3(first_arr[::2])', globals=globals(), number=1000)}")  # Передаем в качестве
# аргумента только четные числа

# На моей машине результаты получились следующие:
# func_1: 0.0910859
# func_2: 0.0506412  LC ожидаемо отрабатывает быстрее команд в классической записи, плюс,
# в отличии от предыдущего примера, тут отсутствует операция, связанная с добавлением каждого чисела в список (append).
# func_3: 0.03066060000000001  Это частный случай, так как мы точно знаем, из каких чисел состоит
# наш список, в случае неизвестного, случайного списка он неприменим. Тут удается "убить двух зайцев"
# - мы обрабатываем вдвое меньшее количество цифр и не проводим операцию проверки для каждого числа, что и дает
# в итоге такой прирост производительности.
