"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Оптимизируйте, чтобы снизить время выполнения
Проведите повторные замеры.

Добавьте аналитику: что вы сделали и почему!!!
Без аналитики задание не принимается

И прошу вас обратить внимание, что то, что часто ошибочно называют генераторами списков,
на самом деле к генераторам отношения не имеет. Это называется "списковое включение" - list comprehension.
"""
from timeit import Timer

def func_1(nums):
    new_arr = []                    # O(1)
    for i in range(len(nums)):      # O(n)
        if nums[i] % 2 == 0:        # O(1)
            new_arr.append(i)       # O(1)
    return new_arr

def func_2(nums):
    new_arr = []                    # O(1)
    i = 0                           # O(1)
    s = len(nums)                   # O(1)
    while i < s:                    # O(1)
        if nums[i] % 2 == 0:        # O(1)
            new_arr.append(i)       # O(1)
        i += 1                      # O(1)
    return new_arr

t1 = Timer("func_1([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])","from __main__ import func_1")
print("func_1",t1.timeit(number=1000000),"секунд")
t2 = Timer("func_1([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])","from __main__ import func_1")
print("func_2",t2.timeit(number=1000000),"секунд")

"""
1 замер 
func_1 11.4445297 секунд
func_2 9.427707700000001 секунд
2 замер 
func_1 10.0455745 секунд
func_2 9.537161699999999 секунд
3 замер
func_1 12.8004117 секунд
func_2 9.656688400000002 секунд
4 замер
func_1 9.5022727 секунд
func_2 6.493831899999998 секунд
5 замер
func_1 8.0080253 секунд
func_2 7.6554962 секунд
6 замер
func_1 13.5373521 секунд
func_2 9.479384999999999 секунд
7 замер
func_1 15.666554 секунд
func_2 14.8814223 секунд
8 замер
func_1 11.2791616 секунд
func_2 7.262406699999998 секунд
9 замер
func_1 7.4328511 секунд
func_2 8.9925831 секунд
10 замер
func_1 11.810887800000001 секунд
func_2 8.665670299999999 секунд

Второй алгоритм выполняется быстрее, так как первоначальный вариант удалось упростить
с линейной сложности до константной, убрав цикл for и функцию range()
"""