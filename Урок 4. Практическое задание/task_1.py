"""
Задание 1.
Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива
Сделайте замеры времени выполнения кода с помощью модуля timeit
Оптимизируйте, чтобы снизить время выполнения
Проведите повторные замеры.
Добавьте аналитику: что вы сделали и почему!!!
Без аналитики задание не принимается
И прошу вас обратить внимание, что то, что часто ошибочно называют генераторами списков,
на самом деле к генераторам отношения не имеет. Это называется "списковое включение" - list comprehension.
"""

import timeit

print(timeit.timeit("""def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr""", number=20000))

"""
0.0017924020000000818
"""

# ОПТИМИЗАЦИЯ:

print(timeit.timeit("""def func_1(nums):
    new_arr = []
    for i, new_arr in enumerate(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return i, new_arr""", number=20000))

"""
0.0017924020000000818
"""

"""
Я помню, на уроке вы говорили, что в этом задании лучше применить enumerate.
Собственно, опираясь на эту информацию я погуглил сравнение enumerate и
range, найдя интересную статью на эту тему. Исходя из информации в статье,
проблема первоначального цикла из ПЗ заключается в том, что он не очень
хорошо соответствует идеологии Python. В этом первоначальном цикле мы
не перебираем список, а, используем вспомогательную переменную i для
обращения к элементам списка. Более по-питоновски, очевидно, будет
использовать enumerate, который позволяет "пересчитать" итерируемый объект.
Да и по времени работа с enumerate получилась экономичнее.
"""
