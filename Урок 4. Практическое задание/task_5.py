"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (теорию по Решету нужно искать в сети)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000

Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма.

Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснование результатам.
"""
import timeit


def simple(i):
    """Без использования «Решета Эратосфена»
    Difficult: O(n^2 * len(n))
    """
    count = 1
    n = 2
    while count <= i:  # O(n)
        t = 1
        is_simple = True
        while t <= n:  # O(n)
            if n % t == 0 and t != 1 and t != n:  # O(len(n))
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:  # O(len(n))
                break
            count += 1
        n += 1
    return n


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i))


def eratosthenes_algorithm(n):
    """Difficult: O(n len(n))
     """
    a = []
    for i in range(n + 1):  # O(n)
        a.append(i)

    # Вторым элементом является единица,
    # которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0
    # начинаем с 3-го элемента
    i = 2
    count = 1
    while i <= n:  # O(n)
        # Если значение ячейки до этого
        # не было обнулено,
        # в этой ячейке содержится
        # простое число.
        if a[i] != 0:  # O(len(n))
            # первое кратное ему
            # будет в два раза больше
            j = i + i
            while j <= n:  # O(n)
                # это число составное,
                # поэтому заменяем его нулем
                a[j] = 0
                # переходим к следующему числу,
                # которое кратно i
                # (оно на i больше)
                j = j + i
        i += 1
    # Превращая список во множество,
    # избавляемся от всех нулей кроме одного.
    a = set(a)
    # удаляем ноль
    a.remove(0)
    return a


print(eratosthenes_algorithm(i))
print('simple ', timeit.repeat('simple(i)', globals=globals(), number=(10**4)))
print('eratosthenes_algorithm ', timeit.repeat('eratosthenes_algorithm(i)', globals=globals(), number=(10**4)))


""" Решить задачу методом Эратосвена не получилось.
Не смотря на то что оба алгоритма решают разный задачи, алгоритм Эратосфена 
справляется с соей в разы быстрее, в нем простая логика что сложные числа всегда можно
 представить как произведение простых. Поэтому если одно сложное число делится на другое сложное, 
 то первое должно делиться на делители второго. Например, 12 делится на 6, делителями которого являются 2 и 3. 
 Число 12 делится и на 2, и на 3.
"""