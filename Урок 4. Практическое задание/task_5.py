"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснвование результатам
"""
from timeit import timeit


def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def sieve(x):
    """«Решето Эратосфена»"""
    # создадим для просеивания список из 1000000 элементов
    n = 1000000
    numbers = list(range(n+1))

    # Единицу не считают простым числом, забиваем ее нулем.
    numbers[1] = 0

    # начинаем с 3-го элемента
    i = 2
    while i <= n:
        # Если значение ячейки до этого не было обнулено,
        # в этой ячейке содержится простое число.
        if numbers[i]:
            # заменяем нулями числа, кратные i
            # начиная с i^2, т.к. все более ранние уже вычеркнуты
            j = i * i
            while j <= n:
                numbers[j] = 0
                j = j + i
        i += 1

    # Превращая список во множество, избавляемся от дубликатов
    # и заново сортируем список
    numbers = list(set(numbers))
    numbers.sort()

    # возвращаем искомое число по индексу
    # нулевым элементом будет 0, следовательно индекс
    # будет соответствовать введённому числу
    return numbers[x]


i = int(input('Введите порядковый номер искомого простого числа: '))
print(f'{i}-е простое число, найденное наивным алгоритмом: {simple(i)}')
print(f'{i}-е простое число, найденное с использованием "решета Эратосфена": {sieve(i)}')
print()

print('Наивный алгоритм:')
print(f"10 элемент найден за {timeit('simple(10)', globals=globals(), number=1)} сек")
print(f"100 элемент найден за {timeit('simple(100)', globals=globals(), number=1)} сек")
print(f"1000 элемент найден за {timeit('simple(1000)', globals=globals(), number=1)} сек")
print(f"10000 элемент найден за {timeit('simple(10000)', globals=globals(), number=1)} сек")
print(f"20000 элемент найден за {timeit('simple(20000)', globals=globals(), number=1)} сек")

print()

print('Решето Эратосфена:')
print(f"10 элемент найден за {timeit('sieve(10)', globals=globals(), number=1)} сек")
print(f"100 элемент найден за {timeit('sieve(100)', globals=globals(), number=1)} сек")
print(f"1000 элемент найден за {timeit('sieve(1000)', globals=globals(), number=1)} сек")
print(f"10000 элемент найден за {timeit('sieve(10000)', globals=globals(), number=1)} сек")
print(f"20000 элемент найден за {timeit('sieve(20000)', globals=globals(), number=1)} сек")

"""
Сложность наивного алгоритма определяется двумя вложенными циклами, 
внешним, перебирающим числа до тех пор, пока не найдётся 
нужное количество простых (имеет сложность O(n)),
и внутренним, подбирающим делители для этих чисел
(так же имеет сложность O(N)).
Общая сложность алгоритма O(n) * O(n) = O(n^2).
Небольшое время работы на маленьком количетве элементов
будет сильно увеличиваться с ростои мх числа.

Для алгоритма нахождения простых чисел с помощью "решета Эратосфена"
доказана сложность O(N*log(logN)).
Благодаря log(logN) время работы алгоритма имеет очень маленький
разброс. Фактически время работы алгоритма будет зависеть от
количества элементов в начальном списке.

Как видно из замеров времени, при просеивании
решетом Эратосфена 1000000 элементов, скорость работы алгоритмов будет
примерно равна на 1000м простом числе.
При необходимости найти меньшее простое число эффективнее
наивный поиск. Однако, при дальнейшем увеличении
номера искомого числа "решето Эратосфена" будет иметь заметный 
выигрыш по скорости выполнения.

Наивный алгоритм:
10 элемент найден за 2.6200000000198287e-05 сек
100 элемент найден за 0.0024241999999996544 сек
1000 элемент найден за 0.3217702 сек
10000 элемент найден за 43.004794999999994 сек
20000 элемент найден за 183.8251411 сек

Решето Эратосфена:
10 элемент найден за 0.38905249999999114 сек
100 элемент найден за 0.38605340000000865 сек
1000 элемент найден за 0.39334639999998444 сек
10000 элемент найден за 0.38511510000000726 сек
20000 элемент найден за 0.38934340000000134 сек
"""
