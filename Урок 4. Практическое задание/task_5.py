"""
Задание 5.**
Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).
Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)
Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма
Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснвование рез-ам
"""

import timeit

# итоговая сложность алгоритма O(n**2)
def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1                   # O(1)
    n = 2       # O(1)
    while count <= i:   # O(n)
        t = 1           # O(1)
        is_simple = True    # O(1)
        while t <= n:   # O(n)
            if n % t == 0 and t != 1 and t != n:    # O(1)
                is_simple = False     # O(1)
                break
            t += 1     # O(1)
        if is_simple:   # O(1)
            if count == i:  # O(1)
                break
            count += 1  # O(1)
        n += 1  # O(1)
    return n # O(1)

# итоговая сложность всегоалгоритма O(N)
def hard(number):
    '''С применением решета Эратосфена'''

    # специально герерируем список так, чтобы индексы совпадали со значениями чисел
    numbers_list = [i for i in range(number + 1)]  # O(N)
    numbers_list[1] = 0

    # сложность алгоритма О(Nlog(logN)),
    # строгое доказательство сложности алгоритма можно найти в книге
    # Hardy и Wright «An Introduction to the Theory of Numbers»
    for num in numbers_list:
        if num != 0:
            help_num = num ** 2
            while help_num <= len(numbers_list) - 1:
                numbers_list[help_num] = 0
                help_num += num

    numbers_list = set(numbers_list)  # O(N)
    numbers_list = list(numbers_list)  # O(N)
    numbers_list.sort()  # O(NlogN)
    return numbers_list[number // 10]  # O(1)


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i))
print(hard(i * 10))     # специально домножнаем на 10, чтобы правильно сформировать список чисел внутри функции

print(timeit.timeit('simple(i)', number=10000, globals=globals()))
print(timeit.timeit('hard(i * 10)', number=10000, globals=globals()))
# итоговая сложность simple - O(n**2), hard - O(n)
# для i = 10 результат: simple - 0.21 с, hard - 0.34 с при number = 10000
# для i = 100 результат: simple - 1.83 с, hard - 0.31 с при number = 1000
# для i = 1000 результат: simple - 44.24 с, hard - 0.43 с при number = 100
# значения входного параметра number в функции timeit специально были выбраны, как указано выше, чтобы снизить время
# ожидания выполнения временных замеров

# Результаты замеров времени показывают, что решето Эратосфена выполняется быстрее на больших значениях входного
# параметра i. С ростом порядкового номера искомого числа simple алгоритм выполняется в разы медленнее, чем hard
# алгоритм. Это связано с тем, что в алгоритме hard более эффективно отсеиваются составные числа. Однако при малых 
# значениях i simple алгоритм оказался эффективнее, чем hard алгоритм. Это связано с тем, что в конце hard алгоритма
# необходимо делать преобразование из списка во множество, затем мн-ва обратно в список и выполнить сортировку вновь
# полученного списка, после чего возможно вернуть требуемое число в качестве ответа. Данные операции повышают сложность
# алгоритма hard с O(Nlog(logN)) до O(N).