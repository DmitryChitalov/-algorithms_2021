"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснвование рез-ам
"""
import timeit

def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n

def eratosfen(i):
    n = 2
    l = 100000
    nat_num = [i for i in range(l)]
    nat_num[1] = 0
    while n < l:
        if nat_num[n] != 0:
            m = n*2
            while m < l:
                nat_num[m] = 0
                m += n
        n += 1
    return [j for j in nat_num if j!=0][i-1]


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i))
print(eratosfen(i))
print(timeit.timeit('simple(i)',
        globals = globals(),
        number = 100))
print(timeit.timeit('eratosfen(i)',
        globals = globals(),
        number = 100))

'''
для поиска 10ого числа:
0.0013073999999999586
3.9176524
для поиска 100ого числа:
0.19565710000000003
3.9352213
для поиска 1000ого числа:
33.4781161
3.8450970999999967
сложнотсь простого перебора O(n^2), а сложность эратосфеновского O(n log(logn))
соответственно чем больше чисел нужно перебрать, тем более эффективно использовать эратосфеновский метод
'''
