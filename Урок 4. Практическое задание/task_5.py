"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000

Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма.

Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснование результатам.
"""
from timeit import timeit


def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def eratosthenes(idx):
    """С использования «Решета Эратосфена»"""
    n = 1000000
    sieve = list(range(n + 1))
    sieve[1] = 0
    for i in sieve:
        if i > 1:
            for j in range(i + i, len(sieve), i):
                sieve[j] = 0
    sieve1 = [x for x in sieve if x != 0]
    return sieve1[idx - 1]


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i))
index = int(input('Введите порядковый номер искомого простого числа: '))
print(eratosthenes(index))

print(f"Время работы функции {simple.__name__} составило {timeit('simple', globals=globals())} сек.")
print(f"Время работы функции {eratosthenes.__name__} составило {timeit('eratosthenes', globals=globals())} сек.")

"""
По решению с Решетом - я не смог найти решение, что б сначала не создавать список, а делать только до нужного числа.
Было принято решению, создасть массив до 1000000. А потом просто брать по индексу.
По результам работы модуля профилирования timeit, получил такие данные:
До 10 числа:
Введите порядковый номер искомого простого числа: 10
29
Введите порядковый номер искомого простого числа: 10
29
Время работы функции simple составило 0.06863989999999998 сек.
Время работы функции eratosthenes составило 0.06406530000000021 сек.
До 10 числа:
Введите порядковый номер искомого простого числа: 100
541
Введите порядковый номер искомого простого числа: 100
541
Время работы функции simple составило 0.060264000000000095 сек.
Время работы функции eratosthenes составило 0.06026430000000005 сек.
До 1000 числа:
Введите порядковый номер искомого простого числа: 1000
7919
Введите порядковый номер искомого простого числа: 1000
7919
Время работы функции simple составило 0.07252869999999945 сек.
Время работы функции eratosthenes составило 0.0635747999999996 сек.

Исходя из этих данных видно, что решение через решето эфективние, хотя он и формирует сначала массив.
Но проигрывает в использование памяти, но это скорее моя ошибка, т.к. не дадумался, сдеать так, что б программа 
отработало только, до нужного числа.
По сложности:
Без использования «Решета Эратосфена» - составляет O(n^2),
C использования «Решета Эратосфена» - составляет O(n log (log n)).
В целом не могу понять, о решета - очень большая сложность, но выполняется оно все равно быстрее.
"""