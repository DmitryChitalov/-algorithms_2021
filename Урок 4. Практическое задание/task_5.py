""" Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту простого числа
(через перебор делителей).

Попробуйте решить эту же задачу, применив алгоритм "Решето Эратосфена"
https://younglinux.info/algorithm/sieve

Подсказка: Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000

Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма.

Укажите формулу сложности О-нотация каждого алгоритма и сделайте обоснование
результатов."""

from timeit import repeat


def simple(i):
    """Без использования «Решета Эратосфена»"""
    # общая сложность алгоритма - O(n ** 2)
    count, n = 1, 2                                 # O(1)
    while count <= i:                               # O(n)
        t = 1                                       # O(1)
        is_simple = True                            # O(1)
        while t <= n:                               # O(n)
            if n % t == 0 and t != 1 and t != n:    # O(1)
                is_simple = False                   # O(1)
                break                               # O(1)
            t += 1                                  # O(1)
        if is_simple:                               # O(1)
            if count == i:                          # O(1)
                break                               # O(1)
            count += 1                              # O(1)
        n += 1                                      # O(1)
    return n                                        # O(1)


def simple_nums_ertsfn(num_simple, len_arr=0):
    """Вычисление num_simple-простых чисел решетом Эратосфена"""
    # общая сложность алгоритма - О(n log n)

    # по крайней мере до 7000 простого числа - достаточно коэф. 11
    # num_simple ** 2 - излишне много
    CFC = 11                                                        # O(1)
    # список заполняем значениями от 0 до num_simple * CFC
    if not len_arr:  # если длина массива не передана явно          # O(1)
        len_arr = (num_simple * CFC)                                # O(1)
    simle_arr = []  # сюда будем собирать найденные простые числа   # O(1)
    nums = [num for num in range(len_arr)]                          # O(n * CFC)
    nums[1] = 0  # 1 - не считают простым числом                    # O(1)
    idx = 2  # начинаем с 3-го элемента                             # O(1)

    while idx <= len_arr - 1:                                       # O(n)

        # если значение ячейки было обнулено до этого - там не простое число
        if not nums[idx]:                                           # O(1)
            idx += 1  # переходим к следующему числу                # O(1)
            continue                                                # O(1)

        # значение ячейки до этого не было обнулено - там простое число
        not_simple_idx = idx + idx                                  # O(1)
        simle_arr.append(nums[idx])  # забираем найденное простое число # O(1)

        # если нашли искомое простое - возвращаем его и дальше не ищем
        if len(simle_arr) == num_simple:                            # O(1)
            # тестовая печать
            # print(f'{len(nums)=} {nums[:10]=} ... {nums[-10:]=}\n'
            #       f'{len(simle_arr)=} {simle_arr[:10]=} ... {simle_arr[-10:]=}')
            return simle_arr[-1]                                    # O(1)

        # проставляем 0 на всех кратных индексах для составных чисел диапазона
        while not_simple_idx <= len_arr - 1:                        # O(log n)
            if nums[not_simple_idx] != 0:                           # O(1)
                nums[not_simple_idx] = 0                            # O(1)
            not_simple_idx += idx                                   # O(1)
        idx += 1  # переходим к следующему индексу                  # O(1)

    # тестовая печать
    # print(f'{len(nums)=} {nums[:10]=} ... {nums[-10:]=}\n'
    #       f'{len(simle_arr)=} {simle_arr[:10]=} ... {simle_arr[-10:]=}')
    # если просеяли весь диапазон, но не нашли искомое по счету простое -
    # вернем последнее найденное
    return simle_arr[-1]                                            # O(1)


if __name__ == '__main__':

    CNT_RUNS, CNT_RPT = 10, 5  # кол-во запусков и повторов замеров
    test_set = 10, 100, 1000

    # idx_simple_num = int(input('Введите порядковый номер искомого '
    #                            'простого числа: '))

    # блок тестов
    for idx_simple_num in test_set:
        print(f'\nНаивный алгоритм поиска простого числа'
              f' №{idx_simple_num}: {simple(idx_simple_num)}')
        time_it_simple = min(repeat('simple(idx_simple_num)', globals=globals(),
                             number=CNT_RUNS, repeat=CNT_RPT))
        print(f'Замер {CNT_RUNS:,d} запусков скрипта simple(): '
              f'{time_it_simple:.4f} сек.')

        print(f'\nАлгоритм "Решето Эратосфена" поиска простого числа '
              f'№{idx_simple_num}: {simple_nums_ertsfn(idx_simple_num)}')
        time_it_ertsfn = min(repeat('simple_nums_ertsfn(idx_simple_num)',
                                    globals=globals(), number=CNT_RUNS,
                                    repeat=CNT_RPT))
        print(f'Замер {CNT_RUNS:,d} запусков скрипта simple_nums_ertsfn(): '
              f'{time_it_ertsfn:.4f} сек.')

"""
При поиске простых чисел небольшого порядка - алгоритмы близки по времени 
работы, на 100-м числе - разница уже становится заметна - 0,0302с против 0,
0052с, при 1000-м числе - разница уже почти на 2 порядка - 4,5261с против 0,
0623с.
Однозначный победитель - алгоритм "Решето Эратосфена". Есть правда нюас, 
что данный алгоритм расчитан не на поиск простого числа по номеру, а на поиск 
простых чисел в диапазоне, в связи с чем пришлось ввести некий коэффициент 
(практическим способом установил, что при поисках по крайней мере до 
7000-ного простого числа - достаточно взять коэффициент 11 от номера искомого 
простого числа. Есть мнение - брать квадрат номера искомого числа, но это 
скорее для поиска "решетом" уже достаточно больших чисел. В любом случае - 
коэффициент можно поменять.  
Общая сложность алгоритмов в О-нотации:
    - наивного поиска - O(n ** 2)
    - решето Эратосфена - О(n log n)
"""