"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000

Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма.

Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснование результатам.
"""

from timeit import Timer


def simple(i):  # Боюсь ошибиться, но думаю, что сложность O(i)
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def simple_2(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n / 2:  # Уменьшил диапазон поиска
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def simple_3(n, len_list=1000):  # Сложность O(n^2) - квадратичная (цикл while, вложенный в другой цикл while)

    a = list(range(len_list+1))

    # Вторым элементом является единица, которую не считают простым числом и забиваем ее нулем.
    a[1] = 0

    # начинаем с 3-го элемента
    i = 2
    while i <= len_list:
        # Если значение ячейки до этого не было обнулено, в этой ячейке содержится простое число.
        if a[i] != 0:
            # первое кратное ему будет в два раза больше
            j = i + i
            while j <= len_list:
                # это число составное, поэтому заменяем его нулем
                a[j] = 0
                # переходим к следующему числу, которое кратно i (оно на i больше)
                j = j + i
        i += 1

    b = [a[i] for i in a if a[i] != 0]

    if len(b) >= n:
        return b[n-1]
    else:
        return simple_3(n, len_list + 1000)


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i))
print(simple_2(i))
print(simple_3(i))

t1 = Timer("simple(i)", "from __main__ import simple, i")
print('t1', t1.timeit(number=10))

t2 = Timer("simple_2(i)", "from __main__ import simple_2, i")
print('t2', t2.timeit(number=10))

t3 = Timer("simple_3(i)", "from __main__ import simple_3, i")
print('t3', t3.timeit(number=10))

# Предложенный по ссылке алгоритм Решета для решения задачи не подошел, так как он возвращает
# не отсортированный set с перечнем простых чисел.
# Модифицировал алгоритм. У него есть недостаток: нельзя заранее предугадать длину списка
# с числами, который потом пропускать через Решето. Вышел из ситуации следующим образом:
# создаю список длиной 1000 элементов, пропускаю через Решето, ищу требуемый порядковый
# номер простого числа. Если число не найдено, значит длины списка не хватило,
# рекурсивно вызываю эту же функцию, увеличив длину списка еще на 1000 элементов.
# Результат следующий: для поиска простого числа с небольшим порядковым номером (до 50)
# в скорости мой алгоритм проигрывает первым двум.
# При поиске простого числа с порядковым номером от 60 - заметный выигрыш в скорости.
# Причина - при меньших значениях n чаще происходит просеивание "не простых" элементов списка

# Введите порядковый номер искомого простого числа: 40
# 173
# 173
# 173
# t1 0.004619067000000143
# t2 0.0029715839999999716
# t3 0.005220481999999915

# Введите порядковый номер искомого простого числа: 60
# 281
# 281
# 281
# t1 0.007349199000000084
# t2 0.0058874890000000235
# t3 0.003011359000000269

# Введите порядковый номер искомого простого числа: 100
# 541
# 541
# 541
# t1 0.022223917999999898
# t2 0.016721414000000046
# t3 0.002973607000000378

# Введите порядковый номер искомого простого числа: 1000
# 7919
# 7919
# 7919
# t1 3.369602923
# t2 2.5275658720000003
# t3 0.11592067800000017
