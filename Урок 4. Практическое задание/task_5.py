"""
Задание 5.**
Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).
Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)
Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма
Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснвование рез-ам
"""

import timeit

def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1                   # O(1)
    n = 2       # O(1)
    while count <= i:   # O(n)
        t = 1           # O(1)
        is_simple = True    # O(1)
        while t <= n:   # O(n)
            if n % t == 0 and t != 1 and t != n:    # O(1)
                is_simple = False     # O(1)
                break
            t += 1     # O(1)
        if is_simple:   # O(1)
            if count == i:  # O(1)
                break
            count += 1  # O(1)
        n += 1  # O(1)
    return n # O(1)


def hard(number_ord):
    '''С применением решета Эратосфена'''

    # специально герерируем список так, чтобы индексы совпадали со значениями чисел
    numbers_list = [i for i in range(number_ord + 1)]   # O(n)
    numbers_list[1] = 0     # 1- не простое и не составное  # O(1)

    i = 2   # O(1)
    while i <= number_ord:  # O(n)
        if numbers_list[i] != 0:    # если значение в ячейке не 0, то 1е число, кратное данному, будет в 2 раза больше
            j = i * 2               # него самого
                                    # O(1)

            while j <= number_ord:      # O(n)
                numbers_list[j] = 0     # это уже составное число
                j += i                  # следующее число, кратное i, больше еще на i
                                        # O(1)

        i += 1                          # O(1)

    numbers_list = set(numbers_list)    # O(n)
    numbers_list.remove(0)              # O(1)
    numbers_list = list(numbers_list)   # O(n)
    numbers_list.sort()                 # O(nlog(n))
    return numbers_list[int(number_ord / 10) - 1]  # O(1)


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i))
print(hard(i * 10))     # специально домножнаем на 10, чтобы правильно сформировать список чисел внутри функции

print(timeit.timeit('simple(i)', number=1, globals=globals()))
print(timeit.timeit('hard(i * 10)', number=1, globals=globals()))
# итоговая сложность simple - O(n**2), hard - O(n**2)
# для i = 10 результат: simple - 0.22 с, hard - 0.36 с при number = 10000
# для i = 100 результат: simple - 4.21 с, hard - 0.642 с при number = 1000
# для i = 1000 результат: simple - 44.39 с, hard - 0.39 с при number = 100
# значения входного параметра number в функции timeit специально были выбраны, как указано выше, чтобы снизить время
# ожидания выполнения временных замеров

# Несмотря на одинаковую теоретическую сложность О(n**2) каждого из двух алгоритмов, результаты замеров времени
# показывают, что решето Эратосфена выполняется быстрее. С ростом порядкового номера искомого числа simple алгоритм
# выполняется в разы медленнее, чем hard алгоритм. Это связано с тем, что в алгоритме hard более эффективно отсеиваются
# составные числа