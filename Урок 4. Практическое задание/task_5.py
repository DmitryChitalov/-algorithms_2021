"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000

Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма.

Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснование результатам.
"""
import math
from timeit import timeit


def simple(i):  # O(n **2 ) Квадратичная сложность, за счет вложенности циклов
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


# Мне понравился этот.
def bit_sieve(n):
    if n < 2:
        return []
    bits = [1] * n
    sqrt_n = int(math.sqrt(n)) + 1
    for s in range(2, sqrt_n):
        if bits[s - 2]:
            for j in range(s + s, n + 1, s):
                bits[j - 2] = 0
    return bits


def compicated(k):  # Сложность с учетом двух функций nlogn - неплохо!
    sieve = bit_sieve(int(1.5 * k * math.log(k)) + 1)
    i = 0
    while k:
        k -= sieve[i]
        i += 1
    return i + 1


if __name__ == '__main__':
    my = [10, 100, 1000]
    for i in my:
        print(f'Для {i} получаем результат: ')
        print(f'Первый алгоритм дает результат <{simple(i)}>')
        print(timeit('simple(i)', globals=globals(), number=5))
        print('##################################################################')
        print(f'Второй алгоритм дает результат <{compicated(i)}>')
        print(timeit('compicated(i)', globals=globals(), number=5))


"""
Для 10 получаем результат: 
Первый алгоритм дает результат <29>
6.0000000000001025e-05
##################################################################
Второй алгоритм дает результат <29>
2.2499999999998216e-05
Для 100 получаем результат: 
Первый алгоритм дает результат <541>
0.0080262
##################################################################
Второй алгоритм дает результат <541>
0.00042440000000000186
Для 1000 получаем результат: 
Первый алгоритм дает результат <7919>
1.2614551
##################################################################
Второй алгоритм дает результат <7919>
0.0070870000000000655
"""

# Очевидно, что разница растет с порядковым номером i, однако, даже на малых значениях i она видна. Алгоритм
# Эратосфена в современной трактовке гораздо эффективнее простого перебора, что показывает результат. Нотация
# подтверждает выводы.
