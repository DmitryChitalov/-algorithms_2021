  
"""
Задание 1.
Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива
Сделайте замеры времени выполнения кода с помощью модуля timeit
Оптимизируйте, чтобы снизить время выполнения
Проведите повторные замеры.
Добавьте аналитику: что вы сделали и почему!!!
Без аналитики задание не принимается
"""

import timeit

def func_1(nums):
# O(n) - линейная сложность
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


def func_2(nums):
# O(N) - линейная сложность
	return [i for i in range(0, len(nums)) if i % 2 == 0] 


def func_3(nums):
# O(n) – линейная сложность
    return [i for i, el in enumerate(nums) if el % 2 == 0]

list_nums = [el for el in range(2000)]


print(
    timeit.timeit(
        "func_1(list_nums)",
        globals=globals(),
        number=1000))

print(
    timeit.timeit(
        "func_2(list_nums)",
        globals=globals(),
        number=1000))

print(
    timeit.timeit(
        "func_2(list_nums)",
        globals=globals(),
        number=1000))

"""
2000
0.19186160000000002  - результат с циклом для списка длиной 2000 
0.114873             - результат с созданием массива генератором в заданном диапазоне
0.14274589999999998  - результат с созданием массива генератором с enumerate 

20000
1.8620715            - результат с циклом для списка длиной 20000 
1.0935624999999998   - результат с созданием массива генератором в заданном диапазоне
1.1070548000000002   - результат с созданием массива генератором с enumerate

2000000
218.76489070000002   - результат с циклом для списка длиной 2000000
156.89363920000002   - результат с созданием массива генератором в заданном диапазоне
154.80519920000006   - результат с созданием массива генератором с enumerate


5000000
386.6219423          - результат с созданием массива генератором в заданном диапазоне
397.495519           - результат с созданием массива генератором с enumerate
"""

# замер времени выполнения показывает, что обход списка в цикле требует больше времени, чем генератор списка по условию. 
# Разные способы задания условия генерации влияют на время выполнения мало 
# - задавать границы массива или выбирать индексы элементов из enumerate() - это дает почти одинаковый результат, но при росте значений N, генератор в заданном диапазоне немного эффективней 



