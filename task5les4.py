import timeit

def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def eratosphen(i):
    n = 2
    l = 10000
    a = [j for j in range(l)]
    a[1] = 0
    while n<l:
        if a[n] != 0:
            m = n + n
            while m < l:
                a[m] = 0
                m = m + n
        n += 1
    return [k for k in a if k != 0][i - 1]


i = int(input('Введите порядковый номер искомого простого числа: '))
print(timeit.timeit("simple(i)", globals=globals(), number=100))
print(timeit.timeit("eratosphen(i)", globals=globals(), number=100))
print(simple(i))
print(eratosphen(i))


""" Результаты измерений:
--------- 10 число ---------
0.00265979999999999
0.5366796000000003
--------- 100 число ---------
0.2558408999999999
0.48746979999999995
--------- 1000 число ---------
39.7374598
0.35481920000000144

Можно заметить, что с увеличение порядкового номера нужного нам простого числа, время работы первого алгоритма увеличивается, а время
работы второго алгоритма уменьшается. То есть можно сделать вывод, что второй алгоритм будет эффективнее для нахождения большего числа.
Так как в первом алгоритме проверяется каждое число из заданного диапазона, что удлинняет работу программы.
Сначала берется первое простое и из ряда натуральных чисел высеиваются все кратные ему. 
Затем берется следующее простое и отсеиваются все кратные ему и так далее. То есть происходит некий процесс отсеивания.
"""