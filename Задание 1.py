#Решение смю Вебинар 4 с 8:30

"""
Задание 1.
Реализуйте свои пользовательские функции, в которых реализуйте:
a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""

# Т.е. Реализуем замеры времени заполнение списка и словаря и времени выполнения разных операций с ними.
# Словарь должен быть быстрее (в основе Хещ-таблицы), чем списое (в основе динамические массивы)
from time import time

empty_list = []
empty_dict = {}
n = 10

def time_decorator(func):
    def time_counter(*args, **kwargs):
        start = time()
        res = func(*args, **kwargs)
        end = time()
        print(f'[*] Время выполнения функции: {func.__name__}'
        f'составило {end - start} секунд.')
        return res
    return time_counter

@time_decorator # Декоратор — это функция, которая позволяет обернуть другую функцию для расширения её функциональности без непосредственного изменения её кода.
# Заполняем список
def fill_list(lst, num):
    for i in range(num):
        lst.insert(0, i) # Сложность О(n) Добавить
        #lst.append(i) # Сложность О(1) Добавить
        #lst.pop(i) # Сложность О(n) Удаление
        #lst[i] = lst[i + 1] # Сложность О(n) Обрашение по индексу с изменением эд-та списка
fill_list(empty_list, n)
print('_' * 100)

# Заполняем словарь
@time_decorator
def fill_dict(dict, num):
    for i in range(num):
        dict[i] = i # Сложность О(1) - Выполнение всех операций в словаре должно быть быстрее
fill_dict(empty_dict, n)
print('_' * 100)