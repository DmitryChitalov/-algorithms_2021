"""
Задание 1.
Реализуйте кодирование строки "по Хаффману".
У вас два пути:
1) тема идет тяжело? тогда вы можете, опираясь на пример с урока, сделать свою!!! версию алгоритма
Разрешается и приветствуется изменение имен переменных, выбор других коллекций, различные изменения
и оптимизации.
2) тема понятна? постарайтесь сделать свою реализацию.
Вы можете реализовать задачу, например, через ООП или предложить иной подход к решению.
"""


"""
Кодирование по Хаффману – частота появления символа в последовательности. 
Символ, который встречается чаще всего, получает новый, очень маленький код. 
Наиболее редко фигурирующий символ, напротив, получает очень длинный код. 
"""

# ЗАДАЧА: Построить бинарное дерево, что бы пройдя по нему узнать коды эл-тов (листьев).

# Мои коментарии ПРОНУМЕРОВАНЫ. Начинать читать код с № 1 (см. конец кода) и т.д.
"""Хаффман через коллекции"""
from collections import Counter, deque

# Фун-ия принимает строку и строит ряд в порядке НЕУБЫВАНИЯ.
def haffman_tree(s):
    # № 4 Считаем уникальные символы нашей строки s = "beep boop beer!". Используем Counter(s). Но результат
    # получается по убыванию Counter({'e': 4, 'b': 3, 'p': 2, ' ': 2, 'o': 2, 'r': 1, '!': 1}),
    # а создаданные узлы бинарного дерева для каждого знака и добавляются в очередь в порядке возрастания
    count = Counter(s)
    # Сортируем по возрастанию количества повторений и передаем в ДЕК.
    # deque([('r', 1), ('!', 1), ('p', 2), (' ', 2), ('o', 2), ('b', 3), ('e', 4)])
    sorted_elements = deque(sorted(count.items(), key=lambda item: item[1]))

    # # № 5 Берем по ДВА эл-та из ДЕКа и формируем из них словари, например 1-е два эл-та.
    # deque([({0: 'r', 1: '!'}, 2), ('p', 2), (' ', 2), ('o', 2), ('b', 3), ('e', 4)])
    # Проверка, если строка состоит из одного повторяющего символа.
    if len(sorted_elements) != 1:
        # Цикл для построения дерева
        while len(sorted_elements) > 1:
            # далее цикл объединяет два крайних левых элемента из ДЕКа.
            # deque([('r', 1), ('!', 1), ('p', 2), (' ', 2), ('o', 2), ('b', 3), ('e', 4)])
            # № 6 Идем и считаем веса, т.е. частоты эл-тов и делаем первый словарь (см. № 6a ниже)
            weight = sorted_elements[0][1] + sorted_elements[1][1]
            # Вес объединенного элемента (накопленная частота)
            # веса - 2, 4, 4, 7, 8, 15
            # Словарь из 2 крайних левых элементов, попутно вырезаем их
            # из "sorted_elements" (из очереди).
            # comb - объединенный элемент
            '''
            {0: 'r', 1: '!'} --------  № 6a получили из ('r', 1), ('!', 1)
            {0: {0: 'r', 1: '!'}, 1: 'p'}
            {0: ' ', 1: 'o'}
            {0: 'b', 1: {0: ' ', 1: 'o'}}
            {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}
            {0: {0: 'b', 1: {0: ' ', 1: 'o'}}, 1: {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}}
            '''
            # № 6a
            comb = {0: sorted_elements.popleft()[0],
                    1: sorted_elements.popleft()[0]}

            # Ищем место для ставки объединенного элемента
            for i, _count in enumerate(sorted_elements):
                if weight > _count[1]:
                # № 7 Т. е. на каждом шаге берем по два эл-та, имеющих наименьшие частоты,
                # строим из них словарь и заполняем ДЕК
                    continue
                else:
                    # № 7a Вставляем объединенный элемент (1-ый маленький словарь) в ДЕК
                    # deque([({0: 'r', 1: '!'}, 2), ('p', 2), (' ', 2), ('o', 2), ('b', 3), ('e', 4)])
                    sorted_elements.insert(i, (comb, weight))
                    break
            else:
                # Добавляем объединенный корневой элемент после
                # завершения работы цикла

                sorted_elements.append((comb, weight))
            '''
            deque([({0: 'r', 1: '!'}, 2), ('p', 2), (' ', 2), ('o', 2), ('b', 3), ('e', 4)])
            deque([(' ', 2), ('o', 2), ('b', 3), ({0: {0: 'r', 1: '!'}, 1: 'p'}, 4), ('e', 4)])
            deque([('b', 3), ({0: ' ', 1: 'o'}, 4), ({0: {0: 'r', 1: '!'}, 1: 'p'}, 4), ('e', 4)])
            deque([({0: {0: 'r', 1: '!'}, 1: 'p'}, 4), ('e', 4), ({0: 'b', 1: {0: ' ', 1: 'o'}}, 7)])
            deque([({0: 'b', 1: {0: ' ', 1: 'o'}}, 7), ({0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}, 8)])
            deque([({0: {0: 'b', 1: {0: ' ', 1: 'o'}}, 1: {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}}, 15)])
                                     Последняя строка (словарь) - наше дерево с весом 15 
            '''
    else:
        # № 8 Извлекаем из ДЕКА словарь и возвращаем его
        # приравниваемыем значение 0 к одному повторяющемуся символу
        weight = sorted_elements[0][1]
        comb = {0: sorted_elements.popleft()[0], 1: None}
        sorted_elements.append((comb, weight))
    # sorted_elements - deque([({0: {0: 'b', 1: {0: ' ', 1: 'o'}}, 1: {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}}, 15)])
    # {0: {0: 'b', 1: {0: ' ', 1: 'o'}}, 1: {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}}
    # словарь - дерево
    return sorted_elements[0][0]


code_table = dict()


# № 2 БОЛЬШОЕ (предположим это оно) дерево - Словарь. В нем малые словари - поддеревья.
# Но есть еще и просто элем-ты Не словарии.
# tree - {0: {0: 'b', 1: {0: ' ', 1: 'o'}}, 1: {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}}
#        ЛЕВАЯ часть дерева (0)              ПРАВАЯ часть дерева (1)

# № 1 Фун-ия принимает на вход дерево.
def haffman_code(tree, path=''):
    # № 2a Если ТИП эл-та дерева не словарь, значит мы достигли самого символа
    # и заносим его, а так же его код в словарь (кодовую таблицу).
    if not isinstance(tree, dict):
        code_table[tree] = path
    # № 2b Если элемент словарь (поддерево), РЕКУРСИВНО спускаемся вниз
    # по первому и второму значению (левая (0) и правая ветви (1)).
    else:
        # № 3 РЕКУРСИЯ - передаем эти маленькие поддеревья той же ф-ии haffman_code. Эта передача происходит
        # до тех пор пока не дойдем до символа и так далее....
        # Переходим с коментариями в начало кода
        haffman_code(tree[0], path=f'{path}0')
        haffman_code(tree[1], path=f'{path}1')


# строка для кодирования
s = "beep boop beer!"

# функция заполняет кодовую таблицу (символ-его код)
# {'b': '00', ' ': '010', 'o': '011', 'r': '1000', '!': '1001', 'p': '101', 'e': '11'}
haffman_code(haffman_tree(s))

# code_table - {'b': '00', ' ': '010', 'o': '011', 'r': '1000', '!': '1001', 'p': '101', 'e': '11'}

# выводим коды для каждого символа
for i in s:
    print(code_table[i], end=' ')
print()
"""
Если необходимо сделать обратную операцию: из кодов получить строку, то нужна либо таблица кодов, 
либо надо знать алгоритм, по которому шла кодировка.
"""