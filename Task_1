"""
Задание 1.
Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.
Можно взять только домашние задания с курса Основ
или с текущего курса Алгоритмов
Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)
ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""

from memory_profiler import memory_usage, profile
from recordclass import recordclass
from timeit import default_timer
import copy
from sys import getrefcount

from random import randint #?

'''Скрипт № 1'''
def decor(func):
    def wrapper(*args):
        start_time = default_timer()
        m1 = memory_usage()
        res = func(*args)
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        end_time = default_timer()
        print(f'Затраты времени: {end_time - start_time} сек.')
        return res, mem_diff
    return wrapper
@decor
def lst_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


@decor
def generator_2(nums):
    return (i for i in range(len(nums)) if nums[i] % 2 == 0)


lst_p = [el for el in range(0,10000000)]
res1, mem_1 = lst_1(lst_p)
print(f"Выполнение заняло {mem_1} Mib")
res2, mem_2 = generator_2(lst_p)
print(f"Выполнение заняло {mem_2} Mib")

'''
Результаты скрипта № 1:
Затраты времени: 3.8897659 сек.
Выполнение заняло 95.94921875 Mib
Затраты времени: 0.20773669999999989 сек.
Выполнение заняло 0.0 Mib

Выводы по скрипту № 1: Генератор позволяет сократить память путем последовательного вывода 
вывода данных вместо записи всех вычислений в память'''

'''Скрипт № 2'''


def memory_time_profiler(func):
    def wraper(*args):
        memory = memory_usage()
        timer = default_timer()
        result = func(*args)
        memory = memory_usage()[0] - memory[0]
        timer = default_timer() - timer
        print(f'Время выполнения: {timer}\nИспользуемая память: {memory}')
        return result
    return wraper
class Complex_Number:
    @memory_time_profiler
    def __init__(self, com_num_1, com_num_2):
        self.number = complex(com_num_1, com_num_2)

    def __str__(self):
        return str(self.number)

    def __add__(self, other):
        return self.number + other.number

    def __mul__(self, other):
        return self.number * other.number
class Complex_Number_2:
    __slots__ = ('number')
    @memory_time_profiler
    def __init__(self, com_num_1, com_num_2):
        self.number = complex(com_num_1, com_num_2)

    def __str__(self):
        return str(self.number)

    def __add__(self, other):
        return self.number + other.number

    def __mul__(self, other):
        return self.number * other.number


com_num_1 = Complex_Number(42, 67)
com_num_2 = Complex_Number_2(42, 67)

'''
Результаты скрипта № 2:
Время выполнения: 0.10436819999999997
Используемая память: 0.00390625
Время выполнения: 0.10596269999999997
Используемая память: 0.0
Выводы по скрипту № 2:
Создание слотов класса позволяет умегьшить использование памяти.
''' 

'''Скрипт № 3'''
# Решение без оптимизации
@profile
def my_func_1():
    x = list(range(1000000))
    y = copy.deepcopy(x)
    return x

# Решение с оптимизацией
@profile
def my_func_2():
    x = list(range(1000000))
    print(getrefcount(x))
    y = copy.deepcopy(x)
    print(getrefcount(y))
    del x
    y = None
    return y
if __name__ == "__main__":
    my_func_1()
    my_func_2()

''' Результаты скрипта № 3:
Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
     9     15.5 MiB     15.5 MiB           1   @profile
    10                                         def my_func_1():
    11     34.7 MiB     19.1 MiB           1       x = list(range(1000000))
    12     38.9 MiB      4.3 MiB           1       y = copy.deepcopy(x)
    13     38.9 MiB      0.0 MiB           1       return x


3
3
Filename: F:/Програмирование/GB Python 2021/Алгоритмы на питон/3/1.py

Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
    16     16.3 MiB     16.3 MiB           1   @profile
    17                                         def my_func_2():
    18     35.1 MiB     18.8 MiB           1       x = list(range(1000000))
    19     35.1 MiB      0.0 MiB           1       print(getrefcount(x))
    20     38.9 MiB      3.9 MiB           1       y = copy.deepcopy(x)
    21     38.9 MiB      0.0 MiB           1       print(getrefcount(y))
    22     35.1 MiB     -3.8 MiB           1       del x
    23     16.6 MiB    -18.6 MiB           1       y = None
    24     16.6 MiB      0.0 MiB           1       return y

Выводы по скрипту № 3:

Удаление списка, который мы больше не планируем использовать
позволяет значительно сэкономить объем памяти.'''