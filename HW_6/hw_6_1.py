"""
Задание 1.

Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.

Можно взять задачи с курса Основ
или с текущего курса Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""
from memory_profiler import memory_usage
from timeit import default_timer


def my_decor(func):
    def check_mem_time(*args):
        t1 = default_timer()
        m1 = memory_usage()
        result = func(*args)
        m2 = memory_usage()
        t2 = default_timer()
        mem_res = m2[0] - m1[0]
        time_res = t2 - t1
        print(f'Память: {mem_res},\nВремя: {time_res}')

    return check_mem_time


# 1

@my_decor
def get_nums_1(end_num):
    res_list = [i for i in range(end_num + 1) if i % 2 == 0 or i % 3 == 0]
    return res_list


@my_decor
def get_nums_2(end_num):
    num_list = list(range(end_num + 1))
    for i in num_list:
        if i % 2 == 0 or i % 3 == 0:
            yield i


get_nums_1(10000000)
get_nums_2(10000000)
print('---------------------------------------------------------------')
'''
Память: 127.93359375,
Время: 2.3456922999999996
Память: 0.0,
Время: 0.2007861000000002
Видно, что генератор использует существенно меньше памяти, при этом скорость выполнния для генератора
так же выше
'''


# 2

@my_decor
def reverse_numb_1(enter_num,
                   revers_num=0):  # в целом работает не корректно, т к если число например 3210, возвращает 123.0
    if enter_num == 0:  # работает медленно из-за множественного вызова функции (рекурсия)
        return revers_num
    else:
        num = enter_num % 10
        revers_num = (revers_num + num / 10) * 10
        enter_num //= 10
        return reverse_numb_1(enter_num, revers_num)


@my_decor
def reverse_numb_2(numb):
    return str(numb)[::-1]


reverse_numb_1(12321432543986842591849312843537664567567563213213125432534557342423634453)
reverse_numb_2(12321432543986842591849312843537664567567563213213125432534557342423634453)

'''
Память: 0.0390625,
Время: 14.871658700000001
Память: 0.0390625,
Время: 15.072202200000001

В данном случае существенного выигрыша по памяти не наблюдается, так же нет разницы и в скорости выполнения скриптов

'''


# 3
@my_decor
def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


@my_decor
def func_4(nums):
    new_arr = list(map(lambda x: x % 2 == 0, nums))
    return new_arr


lst = [i for i in range(1000000)]
print('-------------------------------')
func_1(lst)
func_4(lst)

'''
Память: 9.5703125,
Время: 0.39997040000000084
Память: 4.26171875,
Время: 0.39865829999999747

видно, что функция map расходует память более экономично 

'''
