"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""


data_company = {'company_1': 850000,
                'company_2': 110000,
                'company_3': 235999,
                'company_4': 9000000,
                'company_5': 1000,
                }

# 1 Вариант сложность O(n log n) Линейно-логарифмическая
max_comp = sorted(data_company.items(), key=lambda para: para[1], reverse=True)[:3]  # O(n log N)
for company in max_comp:                                                              # O(n)
    print(f'{company[0]} : {company[1]}')


# 2 Вариант сложность O(n) Линейная
top_company = {}                                                                           # O(1)
temp_dict = dict(data_company)                                                             # O(1)
for i in range(3):  # проходим 3 раза, так нужны топ 3                                     # O(n)
    top = max(temp_dict.items(), key=lambda val: val[1])  # получаю кортеж с макс. данными # O(n)
    top_company[top[0]] = top[1]  # добавляю макс. в словарик                              # O(1)
    del temp_dict[top[0]]  # удаляю взятый макс. что бы не было повтора                    # O(1)
for company, profit in top_company.items():                                                # O(n)
    print(f'{company} : {profit}')


# Второй вариант подходит лучше, так как сложность линейная и соответственно с ростом данным,
# время выполнения будет меньше чем у Линейно-логарифмической модели.

