"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""

# реализуем хранение данных через список кортежей
company_list = [
    ('company_1', 2500000),
    ('company_7', 50000),
    ('company_5', 2500),
    ('company_4', 600000),
    ('company_3', 530000),
    ('company_6', 250000),
    ('company_2', 2000),
    ('company_8', 1234500),
    ('company_9', 6789000),
    ('company_10', 90000)
]


# Вариант 1:
# Сортируем список по убыванию, ориентируясь на прибыль компании
# Выводим 3 первых элемента
# Итоговая сложность алгоритма: O(n log n) - линейно-логарифмическая

company_list.sort(key=lambda x: x[1], reverse=True)
# O(n log n) - линейно-логарифмическая сложность, сортировка списков
for el in range(3):             # O(1) - константная сложность, всегда одинаковое количество итераций
    print(company_list[el])     # O(1) - константная сложность, обращение к элементу по индексу

print()


# Вариант 2:
# Создаём копию списка, что бы не потерять исходные данные
# Производим циклический поиск и удаление максимального элемента списка
# Итоговая сложность алгоритма: O(n) - линейная

company_copy = company_list.copy()                      # O(n) - линейная, копирование списка
for i in range(3):                                      # O(1) - константная сложность
    max_el = max(company_copy, key=lambda x: x[1])      # O(n) - линейная, поиск максимума в списке
    print(max_el)                                       # O(1) - константная сложность
    company_copy.remove(max_el)                         # O(n) - линейная, удаление из списка


# При небольшом количестве элементов первый вариант будет эффективнее.
# При больших значениях n преимущество второго варианта, с линейной сложностью будет увеличиваться.
