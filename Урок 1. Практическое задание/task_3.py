
"""
Задание 3.
Для этой задачи:
1) придумайте 2-3 решения (не менее двух) разной!! сложности
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему
Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
Задание творческое. Здесь нет жестких требований к выполнению.
"""
                                                                    # 4 + 4n*log(n) = O(n*log(n))
my_dict = {'apple':1000, 'samsung':700, 'xiaomi':800, 'huawei':500}                                 # len(my_dict) = 4
print((list((dict(sorted(my_dict.items(), key=lambda item: item[1], reverse=True))).keys()))[:3])   # n*log(n) * 4


print()          # 4 + 1 + n + 1 + n*log(n) + 1 = n*log(n) + n + 7 = O(n*log(n))
my_dict = {'apple':1000, 'samsung':700, 'xiaomi':800, 'huawei':500}             # 4
my_list2 = []                                                                   # 1
for i in my_dict:                                                               # n
    my_list2.append(((i, my_dict.get(i))))                                      # 1*1
#print(my_list2)
x = sorted(my_list2, key=lambda item: item[1], reverse = True)                  # n*log(n)
#print(my_list2)
print(f'1st: {my_list2[0][0]}, 2st: {my_list2[1][0]}, 3st: {my_list2[2][0]}')   # 1*1*1


print()                 # 4 + 1 + n + 1 + 1 + n + n**2 + 1  =  n**2 + 2n + 8  =  O(n**2)
my_dict = {'apple':1000, 'samsung':700, 'xiaomi':800, 'huawei':500}                     # 4
my_list3 = []                                                                           # 1
for i in my_dict:                                                                       # n
    my_list3.append(((i, my_dict.get(i))))                                              # 1*1
num = 0                                                                                 # 1
while num != 3:                                                                         # n
    print(my_list3.pop((my_list3.index(max(my_list3, key=lambda item: item[1])))))      # n*1*n
    num += 1                                                                            # 1

#print(my_list3)
#print(my_list3.pop((my_list3.index(max(my_list3, key=lambda item: item[1])))))
#print(my_list3)


#       ВЫВОД: Самое простое по сложности второе выражение, т.к. формула проще, чем у остальных 2х,
# хотя и первое выражение примерно на столько же сложное, да и строк там меньше, но тем не менее
# второе проще для машины как мне кажется.
#       Решение не виде функции, т.к. в ТЗ ничего не говорится о представлении ответа в виде функции.
