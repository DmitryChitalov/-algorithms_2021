"""
Задание 3.
Для этой задачи:
1) придумайте 2-3 решения (не менее двух) разной!! сложности
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему
Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
Задание творческое. Здесь нет жестких требований к выполнению.
"""

companies = {
    'redhat': 434000000,
    'cisco': 11000000000,
    'mikrotik': 90000000,
    'amd': 3200000000,
    'intel': 1999000000,
    'rik': 132413455123,
    'apple': 1455123335,
    'dell': 13500199588,
}

###############################################################################
profits = [value for value in
           companies.values()]  # Не совсем знаю как описать сложность list comp. или здесь необходимо
# смотреть по присваиванию, что считать в конечном итоге? присваивание O(1), лс - O(n)
profits.sort(reverse=True)  # O(NlogN)
for key in companies.keys():  # O(n)
    if companies[key] in profits[:3]: print(key, companies[key])  # O(n) для цикла, O(3-0) для среза
# Итоговая сложность - O(nlogn)


###############################################################################
top3 = []  # O(1)
for _ in range(3):  # O(3)
    top3.append(companies.popitem())  # O(1)

for key, val in companies.items():  # O(1) для .items() и O(N) для цикла
    for i in range(len(top3)):  # O(N)
        if val > top3[i][1]:  # O(1)
            top3[i] = key, val  # O(1)

print(top3)
# Итоговая сложность - O(n^2)


###############################################################################
names_profits = [(key, val) for key, val in companies.items()]  # O(n)
maximum = []  # O(1)
for i in range(3):  # O(3)
    temp_max = max(names_profits, key=lambda i: i[1])  # O(N)
    maximum.append(temp_max)  # O(1)
    names_profits.remove(temp_max)  # O(n)
# Сложность - O(n)
print(maximum)

# Лучше всего использовать последний вариант решения, т.к он является линейным -> наиболее лёгким по сложности. также
# используются многие встроенные инструменты пайтон, которые интерпретатор отрабатывает быстрее, и происходят
# изменения на месте со списками, что должно сказываться на памяти.

