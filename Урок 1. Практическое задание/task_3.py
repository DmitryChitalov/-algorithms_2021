"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух) разной!! сложности
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.

Задание творческое. Здесь нет жестких требований к выполнению.
"""

from copy import deepcopy as dc


company_list = [['Apple', 3000],
                ['HP', 1500],
                ['ASUS', 1000],
                ['DELL', 1350],
                ['ACER', 1150],
                ['Lenovo', 900]]


# ----------------------------------------------
# Вариант 1. Сортировка по выручке и вывод ТОП-3 - сложность О(n log n)
print('*' * 5, 'Вариант 1. Сортировка и срез Топ-3')
# Для теста делается копия списка, чтобы исходный оставить для других примеров
company_list1 = dc(company_list)                        # скорее всего тут О(n)
company_list1.sort(key=lambda x: x[1], reverse=True)    # O(n log n)
print(*company_list1[:3], sep='\n')                     # O(n)


# ----------------------------------------------
# Вариант 2. Исключение максимума - сложность алгоритма имеет порядок О(n)
print('*' * 5, 'Вариант 2. Добавление Топ-3 максимумов в результаты и исключение из исходного списка найденного')
company_list2 = dc(company_list)                        # скорее всего тут О(n)
res_top = list()
for top in range(3):                                    # О(1) - нельзя писать О(3)
    pos_max = 0
    for pos, i in enumerate(company_list2):             # O(n)
        pos_max = pos if i[1] > company_list2[pos_max][1] else pos_max  # O(1)
    res_top.append(company_list2.pop(pos_max))          # O(1)
print(*res_top, sep='\n')

# 3. Вывод:
""" Второе решение эффективнее первого по причине того, в нем не используется сортировка, выполняемая за О(n log n).
Во втором решении делается три прохода по списку компания и выбираются максимумы. После нахождения максимума данное
значение добавляется в отдельный список методом с O(1), который после завершения будет в отсортированном состоянии
и готов к выводу пользователю.
Оба решения для копирования структуры списка используются deepcopy(), который по данным документации работает за O(n) 
"""
