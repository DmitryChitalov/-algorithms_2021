"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""

# реализуем хранение данных через список кортежей
company_list = [
    ('company_1', 2500000),
    ('company_2', 50000),
    ('company_3', 2500),
    ('company_4', 600000),
    ('company_5', 530000),
    ('company_6', 250000),
    ('company_7', 2000),
    ('company_8', 1234500),
    ('company_9', 6789000),
    ('company_10', 90000)
]

# Вариант 1:
# Сортируем список по убыванию, ориентируясь на прибыль компании
# Выводим 3 первых элемента
# Итоговая сложность алгоритма: O(n log n) - линейно-логарифмическая

company_list.sort(key=lambda x: x[1], reverse=True)
# O(n log n) - линейно-логарифмическая сложность, сортировка списков
for i in range(3):             # O(1) - константная сложность, всегда одинаковое количество итераций
    print(company_list[i])     # O(1) - константная сложность, обращение к элементу по индексу

print()

# Вариант 2:
# Создаём копию списка, что бы не потерять исходные данные
# Производим циклический поиск и удаление максимального элемента списка
# Итоговая сложность алгоритма: O(n) - линейная

company_copy = company_list.copy()                      # O(n) - линейная, копирование списка
for _ in range(3):                                      # O(1) - константная сложность
    max_el = max(company_copy, key=lambda x: x[1])      # O(n) - линейная, поиск максимума в списке
    print(max_el)                                       # O(1) - константная сложность
    company_copy.remove(max_el)                         # O(n) - линейная, удаление из списка

# При небольшом количестве элементов первый вариант будет эффективнее.
# При больших значениях n преимущество второго варианта, с линейной сложностью будет увеличиваться.

print()

# Вариант 3:
# Поиск трёх максимальных элементов за 1 проход
# Итоговая сложность алгоритма: O(n) - линейная
max_1 = max_2 = max_3 = ['', 0]  # O(1) - константная, присваивания
for el in company_list:          # O(n) - линейная
    if el[1] > max_1[1]:         # Далее в цикле используются
        max_3 = max_2            # только сравнения элементов
        max_2 = max_1            # и присваивания
        max_1 = el               # O(1) - константная
    elif el[1] > max_2[1]:
        max_3 = max_2
        max_2 = el
    elif el[1] > max_3[1]:
        max_3 = el
print(max_1, max_2, max_3, sep='\n')

# Последний вариант является наиболее эффективным,
# так как находит все 3 максимальных элемента
# за 1 проход по списку.
# В то время, как во втором варианте необходим проход
# по списку для каждого поиска максимального
# элемента и его удаления.
