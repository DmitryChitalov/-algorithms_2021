"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух) разной!! сложности
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.

Задание творческое. Здесь нет жестких требований к выполнению.
"""

# 1 вариант         СЛОЖНОСТЬ      O(n)

'''
Не проверяем длину списка допускаем, что он всегда более 3, а также понимаем,
что максимальная выручка у 4 компаний, поэтому алгоритмы могут в базе давать
разные результаты, которые формально можно считать верными.  
'''


def max1(l: list) -> int:
    '''
    Максимальное значение списка. Сложность O(n)
    :param l:
    :return: индекс элемента списка l с максимальным значением
    '''
    tmp_id = 0                          # O(1)
    digit = l[tmp_id][1]                # O(1)
    for id in range(1, len(l)):         # O(n)
        if digit < l[id][1]:            # O(1)
            digit = l[id][1]            # O(1)
            tmp_id = id                 # O(1)
    return tmp_id                       # O(1)


company_values = [('Компания 4', 400), ('Компания 5', 150), ('Компания 6', 350),
                  ('Компания 1', 100), ('Компания 2', 200), ('Компания 3', 300),
                  ('Компания 7', 300)]                      # O(1)

cnt, newlist = 3, []                                        # O(1)
while cnt:                                                  # O(n)
    newlist.append(company_values[max1(company_values)])    # O(n)
    del company_values[max1(company_values)]                # O(1)
    cnt -= 1                                                # O(1)
print(*newlist)                                              # O(1)


# 2 вариант           СЛОЖНОСТЬ    O(n)

company_values = {'Компания 4': 400, 'Компания 5': 150, 'Компания 6': 350,
                  'Компания 1': 100, 'Компания 2': 200, 'Компания 3': 300,
                  'Компания 7': 300}                        # O(1)

new_dict = {}                                               # O(1)

for id in range(3):                                         # O(n)
    maxkey = max(company_values, key=company_values.get)    # O(n)
    new_dict[maxkey] = company_values.pop(maxkey)           # O(1)
print(new_dict)                                             # O(1)


# 3 вариант            СЛОЖНОСТЬ O(n log n)

company_values = {'Компания 4': 400, 'Компания 5': 150, 'Компания 6': 350,
                  'Компания 1': 100, 'Компания 2': 200, 'Компания 3': 300,
                  'Компания 7': 300}                                # O(1)

values = sorted(list(company_values.values()), reverse=True)[:3]    # O(n log n)
for k, v in company_values.items():                                 # O(n)
    if v in values:                                                 # O(1)
        print(f'{k}={v}')                                           # O(1)



print('*'*40,'\nВывод:\n',\
      'Метод 1 и 2 одинаково эффективны, ибо их цена O(n) меньше чем у варианта 3 O(n log n)\n',\
      'если верно выполнена нотация.')
