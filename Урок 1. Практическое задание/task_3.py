"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""


def find_profitable_companies_1(company_profits):
    """
    Функция получает на вход словарь {company_profit : company_name}.
    Находит максимальный профит, перебирая и сравнивая значения всех ключей,
    затем удаляет найденый максимальный элемент и
    добавляет его в словарь с результатами
    Сложность данного алгоритма: 2*n + 18 (линейная)
    """
    most_profitable = dict()  # O(1)
    for i in range(3):  # O(1)
        dict_items = list(company_profits.items())  # O(n)
        max_profit = dict_items[0][1]  # O(1) + O(1) + O(1)
        for j in range(1, len(dict_items)):  # O(n) + O(1)
            if max_profit < dict_items[j][1]:  # O(1) + O(1) + O(1)
                max_profit = dict_items[j][1]  # O(1) + O(1) + O(1)
                company_name = dict_items[j][0]  # O(1) + O(1) + O(1)
        most_profitable.update({company_name: company_profits.pop(company_name)})  # O(1) + O(1)
    return most_profitable  # O(1)


def find_profitable_companies_2(company_profits):
    """
    Функциця сортирует входящий словарь по значениям и выводит последний 3 элемента,
    которые имеею максимальной значение.
    Сложность данного алгоритма: n * log n + 3 * n (линейно - логарифмическая)
    """
    lst = list(company_profits.items())  # O(n)
    lst.sort(key=lambda i: i[1])  # O(n log n) + O(n)
    return lst[-3:len(lst)]  # O(n)


my_dict = {'ASUS': 1, 'MSI': 2, 'BMV': 3, 'AUDI': 4, 'LADA': 5}
print(find_profitable_companies_2(my_dict))
print(find_profitable_companies_1(my_dict))
"""
Вывод: необходимо использовать первый алгоритм решения задачи, т.к.
уже при наличае 100 элементов в исходных данных
алгоритм линейно логарифмический примерно в 6 раз менее эффективен,
чем линейный, который используется в функции  find_profitable_companies_1()
"""
