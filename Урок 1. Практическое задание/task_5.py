"""
Задание 5.
Задание на закрепление навыков работы со стеком
Реализуйте структуру "стопка тарелок".
Мы можем складывать тарелки в стопку и при превышении некоторого значения
нужно начать складывать тарелки в новую стопку.
Структура должна предусматривать наличие нескольких стеков.
Создание нового стека происходит при достижении предыдущим стеком порогового значения.
Реализуйте по аналогии с примером, рассмотренным на уроке, необходимые методы,
для реализации это структуры, добавьте новые методы (не рассмотренные в примере с урока)
для реализации этой задачи.
После реализации структуры, проверьте ее работу на различных сценариях
Подсказка:
Отдельне стопки можно реализовать через:
1) созд-е экземпляров стека (если стопка - класс)
или
2) lst = [[], [], [], [],....]
"""


class StackClass:
    """
    stack_size - максимальное колличество элементов в стопке.
    Передается при создании экземпляра класса.
    """

    def __init__(self, stack_size):
        self.elems = [[]]
        self.max_stack_size = stack_size

    def is_empty(self):
        """
        Проверка на наличие элементов в стеке.
        :return:
        """
        return self.elems == [[]]

    def push_in(self, elem):
        """
        Добавляет элемент в конец последней стопки стека.
        Если размер последней стопки превышает максимальный размер,
        то создается новая стопка и элемент добавляется в неё.
        :param elem:
        :return:
        """
        if len(self.elems[-1]) == self.max_stack_size:
            self.elems.append([])
        self.elems[-1].append(elem)

    def pop_out(self):
        """
        Вырезает и возвращает последний элемент в стеке.
        :return:
        """
        if len(self.elems[-1]) == 1:
            last_stack_elem = self.elems.pop()
            return last_stack_elem[-1]
        return self.elems[-1].pop()

    def get_val(self):
        """
        Возвращает последний элемент в стеке.
        :return:
        """
        return self.elems[-1][-1]

    def stack_size(self):
        """
        Возвращает информацию о колличестве элементов и колличество стопок в стеке.
        :return:
        """
        sum_stack = 0
        for el in self.elems:
            sum_stack += len(el)
        return f'Количество стопок в стеке: {len(self.elems)}\n' \
               f'Количество элементов в стеке: {sum_stack}'

    def stack_print(self):
        """
        Вывод состояния стека
        :return:
        """
        return f"Cтек:\n" \
               f"{self.elems}"


# создаем экземпляр класса. Параметр передает макимальное колличество элементов в стопке.
SC_OBJ = StackClass(7)

print(SC_OBJ.is_empty())  # -> стек пустой

# наполняем стек
SC_OBJ.push_in(10)
SC_OBJ.push_in('code')
SC_OBJ.push_in(False)
SC_OBJ.push_in(5.5)
for i in range(13):
    SC_OBJ.push_in(i+1)

# выводим состояние стека
print(SC_OBJ.stack_print())

# получаем значение первого элемента с вершины стека, но не удаляем сам элемент из стека
print(SC_OBJ.get_val())  # -> 13

# выводим колличество стопок и элементов в стеке.
print(SC_OBJ.stack_size())

print(SC_OBJ.is_empty())  # -> стек уже непустой

# кладем еще один элемент в стек
SC_OBJ.push_in(4.4)

# выводим состояние стека
print(SC_OBJ.stack_print())

# убираем элемент с вершины стека и возвращаем его значение
print(SC_OBJ.pop_out())  # -> 4.4

# снова убираем элемент с вершины стека и возвращаем его значение
print(SC_OBJ.pop_out())  # -> 13

# выводим колличество стопок и элементов в стеке.
print(SC_OBJ.stack_size())
