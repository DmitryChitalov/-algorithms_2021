"""
Задание 4.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.

Сама задача:
Пользователи веб-ресурса проходят аутентификацию.
В системе хранятся логин, пароль и отметка об активации учетной записи.

Нужно реализовать проверку, может ли пользователь быть допущен к ресурсу.
При этом его учетка должна быть активирована.
А если нет, то польз-лю нужно предложить ее пройти.

Приложение должно давать ответы на эти вопросы и быть реализовано в виде функции.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
"""


# Вариант 1 - O(N)
def autentification(log_pas):
    login = input('Введите логин: ')
    if login in log_pas.keys():
        password = input('Введите пароль: ')
        while log_pas[login][0] != password:
            print('Пароль неверный!')
            password = input('Введите пароль: ')
        print('Авторизация прошла успешно!')
        log_pas[login][1] = 1
    else:
        print('Логин не найден. Зарегистрируйтесь в системе!')
        user_login = input('Введите логин: ')
        user_password = input('Введите пароль: ')
        log_pas[user_login] = [user_password, 1]


passwords = {
    'login': ['password', 0],
    'log': ['123', 0],
    'a': ['1', 0]
}


# Вариант 2 - O(NlogN)
def binary_search(lst, number):  # O(log n)
    start = 0
    end = len(lst) - 1

    while start <= end:
        mid = int((start + end) / 2)
        if lst[mid] == number:
            return True
        elif lst[mid] < number:
            start = mid + 1
        else:
            end = mid - 1
    return False


def autentification2(log_pas):
    login = input('Введите логин: ')
    password = input('Введите пароль: ')

    log_pas2 = sorted(log_pas.keys())  # O(NlogN)
    if binary_search(log_pas2, login):
        while log_pas[login][0] != password:
            print('Пароль неверный!')
            password = input('Введите пароль: ')
    else:
        print('Логин не найден. Зарегистрируйтесь в системе!')
        user_login = input('Введите логин: ')
        user_password = input('Введите пароль: ')
        log_pas[user_login] = [user_password, 0]
    print('Авторизация прошла успешно!')
    log_pas[login][1] = 1


autentification(passwords)
for key, value in passwords.items():  # проверяем, как отработала функция
    print(key, ': ', value)

autentification2(passwords)
for key, value in passwords.items():
    print(key, ': ', value)


# Вывод: во втором случае мы ускорили поиск за счет применения бинарного поиска, но для его реализации пришлось
# предварительно отсортировать логины. И делать это придется при каждом добавлении нового логина. Поэтому в итоге
# второй алгоритм работает дольше из-за сортировки.
