"""
Задание 4.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.

Сама задача:
Пользователи веб-ресурса проходят аутентификацию.
В системе хранятся логин, пароль и отметка об активации учетной записи.

Нужно реализовать проверку, может ли пользователь быть допущен к ресурсу.
При этом его учетка должна быть активирована.
А если нет, то польз-лю нужно предложить ее пройти.

Приложение должно давать ответы на эти вопросы и быть реализовано в виде функции.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
"""

"""
Вариант 1
Используем логин как ключ в словаре. Это дает возможность ускорить поиск.
"""
# Итоговую сложность определяем по самой "длинной" цевочке действий. Она равна 9.
def f_auth_1(p_login):
    one_user = wrh.get(p_login)  # O(1)
    if one_user is not None:  # O(1)
        # Пользователь допущен к ресурсу. Требуется проверить активирована ли учетная запись.
        if not one_user[1]:  # O(1)
            v_symbol = input('Ваша учетная запись не активирована. Наберите любой символ, чтобы активировать: ')  # O(1)
            if v_symbol != '':  # O(1)
                one_user[1] = True  # O(1)
                wrh.update(p_login=one_user)  # O(1)
                print(f'Учетная запись для {p_login} активирована')  # O(1)
                print(f'Итоговое хранилище: \n{wrh}')  # O(1)
    else:
        print('Ваша учетная запись не имеет доступа к ресурсу')  # O(1)


"""
Вариант 2
Для хранилища используем словарь, но при этом ключом будет не само значение логина, а другое значение
"""
# Итоговую сложность определяем по самой "длинной" цевочке действий. Она равна N + 7.
def f_auth_2(p_login):
    # Находим пользователя с указанным логином. За один перебор словаря вытаскиваем нужную информацию
    one_user = [(ind, val) for (ind, val) in wrh.items() if val[0] == p_login]  # O(N)
    if one_user != []:  # O(1)
        if not one_user[0][1][2] and \
                input('Ваша учетная запись не активирована. Наберите любой символ, чтобы активировать: ') != '':  # O(2)
            one_user[0][1][2] = True  # O(1)
            wrh[one_user[0][0]] = one_user[0][1]  # O(1)
            print(f'Учетная запись для {p_login} активирована')  # O(1)
            print(f'Итоговое хранилище: \n{wrh}')  # O(1)
    else:
        print('Ваша учетная запись не имеет доступа к ресурсу')  # O(1)


print(f'----------------------- ТЕСТ 1 --------------------------')
# Для хранилища используем словарь, при этом ключом будет само знаечение логина.
wrh = {"Login1": ['password1', True], "Login2": ['password2', False], "Login3": ['password3', True],
       "Login4": ['password4', False]}
print(f'Исходное хранилище: \n{wrh}')
v_login = input('Введите Ваш логин: ')
f_auth_1(v_login)

print(f'----------------------- ТЕСТ 2 --------------------------')
# Для хранилища используем словарь, но при этом ключом будет не само значение логина, а другое значение
wrh = {'User1': ['Login1', 'password1', True], 'User2': ['Login2', 'password2', False],
       'User3': ['Login3', 'password3', True], 'User4': ['Login4', 'password4', False]}
print(f'Исходное хранилище: \n{wrh}')
v_login = input('Введите Ваш логин: ')
f_auth_2(v_login)

# Вывод: ключевым фактором в оценке эффективности двух алгоритмов является выбор организации хранилища.
# Если ключом словаря будет login, то это даст преимущество в скорости алгоритма. То есть выбор за вариантом 1.
