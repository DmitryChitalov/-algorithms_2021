"""
Задание 2.

Реализуйте два алгоритма.

Первый, в виде функции, должен обеспечивать поиск минимального значения для
списка. В основе алгоритма должно быть сравнение каждого числа со всеми
другими элементами списка. Сложность такого алгоритма: O(n^2) - квадратичная.
min_simple_alg(lst_in)

Второй, в виде функции, должен обеспечивать поиск минимального значения для
списка. Сложность такого алгоритма: O(n) - линейная.
min_smart_alg(lst_in)

Не забудьте указать сложность каждого из двух алгоритмов. Для лучшего
закрепления темы можете определить и указать сложность еще и у каждого
выражения этих двух алгоритмов.

Примечание: Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
Постарайтесь не использовать ф-ции min() и sort() и другие ф-ции!
Подход должен быть максимально алгоритмическим.
"""


def min_simple_alg(lst_in):
    """
    Функция возвращает минимальный элемент переданного на вход однородного
    списка элементов, которые сравнимы между собой по типу.
    :param lst_in: список для поиска минимального значения
    :return: el_min, idx_min
    кортеж из минимального элемента переданного на вход списка и его индекс,
    если минимальных эл-тов несколько - возвращается индекс 1-го,
    (None, None) - если передан пустой список
    Обеспечивает поиск минимального значения для списка.
    В основе алгоритма - сравнение каждого числа со всеми другими элементами
    списка. Сложность алгоритма: O(N**2) - квадратичная.
    """
    # если список пустой или с 1 элементом - завершаем досрочно
    if not lst_in:                  # O(1)
        return None, None           # O(1)
    if len(lst_in) == 1:            # O(1)
        return lst_in[0], 0         # O(1)

    # запоминаем в качестве минимального 1й эл-т списка
    el_min, idx_min = lst_in[0], 0  # O(1)

    # Перебираем в 1-ом цикле все элементы списка (также берем индекс)
    for idx_is_min, el_is_min in enumerate(lst_in):         # O(N)
        # во 2м цикле сравниваем выбранный эл-т списка с каждым из всего списка
        for el in lst_in:                                   # O(N)
            # если проверяемый эл-т меньше текущего эл-та и меньше текущего
            # минимума, то сохраняем проверяемый эл-т и его индекс в качестве
            # текущего минимума
            if el_is_min < el and el_is_min < el_min:       # O(1)
                el_min, idx_min = el_is_min, idx_is_min     # O(1)
    # сравним каждый эл-т списка с каждым - получаем в текущем минимуме -
    # абсолютный минимум в списке и индекс его 1го вхождения в список,
    # возвращаем их
    return el_min, idx_min                                  # O(1)


def min_smart_alg(lst_in):
    """
    Функция возвращает минимальный элемент переданного на вход однородного
    списка элементов, которые сравнимы между собой по типу.
    :param lst_in: список для поиска минимального значения
    :return: (min_el, idx_min_el)
    кортеж из минимального элемента переданного на вход списка и его индекс,
    если минимальных эл-тов несколько - возвращается индекс 1-го,
    (None, None) - если передан пустой список
    Обеспечивает поиск минимального значения для списка.
    В основе алгоритма - сравнение текущего минимума с каждым эл-том списка
    за 1 проход по списку. Сложность алгоритма: O(N) - линейная.
    """
    # если список пустой или с 1 элементом - завершаем досрочно
    if not lst_in:                  # O(1)
        return None, None           # O(1)
    if len(lst_in) == 1:            # O(1)
        return lst_in[0], 0         # O(1)

    # запоминаем в качестве минимального 1й эл-т списка
    el_min, idx_min = lst_in[0], 0  # O(1)

    # Перебираем в 1-ом цикле все элементы списка (также берем индекс)
    for idx, el in enumerate(lst_in):   # O(N)
        if el < el_min:                 # O(1)
            el_min, idx_min = el, idx   # O(1)
    return el_min, idx_min              # O(1)


if __name__ == '__main__':

    # Тестовые наборы
    test_lst = [
        [],
        [666],
        [1, 2, 1, 3, 1],
        [2, -1, 0],
        [1.01, 3e-2, 2],
        [-1, -3, -3.01, 2],
        ['яйцо', 'курица', 'Бог']
        ]

    # Блок тестирования
    for current_lst in test_lst:
        min_el_on2, min_idx_on2 = min_simple_alg(current_lst)
        min_el_on, min_idx_on = min_smart_alg(current_lst)
        print(f'Список элементов: {current_lst}')
        print(f'Минимальный элемент O(N**2): {min_el_on2} с индексом '
              f'{min_idx_on2}')
        print(f'Минимальный элемент O(N): {min_el_on} с индексом '
              f'{min_idx_on}')
        print('===================================================')
