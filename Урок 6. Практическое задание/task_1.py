"""
Задание 1.

Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.

Можно взять только домашние задания с курса Основ
или с текущего курса Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""

from timeit import default_timer
from memory_profiler import memory_usage


def decor(func):
    def wrapper(*args):
        start = default_timer()
        before = memory_usage()
        res = func(*args)
        after = memory_usage()
        end = default_timer()
        print('---------------------------------------------')
        print(f'Функция {func.__name__}:')
        print(f'\tВремя выполнения - {end - start} c')
        print(f'\tИспользуемая память - {after[0] - before[0]} MiB')
        print('---------------------------------------------')
        return res
    return wrapper

##################################### СКРИПТ 1 ########################################

class CarBase:  # обычный класс Car
    def __init__(self, name, color, speed, is_police=False):
        self.name = name
        self.color = color
        self.speed = speed
        self.is_police = is_police

    def go(self):
        return 'движется'


class CarOptimize:  # оптимизированный класс Car
    __slots__ = ['name', 'color', 'speed', 'is_police']     # применим слоты
    def __init__(self, name, color, speed, is_police=False):
        self.name = name
        self.color = color
        self.speed = speed
        self.is_police = is_police

    def go(self):
        return 'движется'


@decor
def car_base():  # создаем машину из обычного класса
    car = CarBase('ВАЗ 2106', 'красный', 80, False)
    print(car.name, car.go())


@decor
def car_optimaze():  # создаем машину из оптимизированного класса
    car = CarOptimize('Лада Веста', 'белый', 120, False)
    print(car.name, car.go())


if __name__ == '__main__':
    car_base()
    car_optimaze()

"""
вывод
    ВАЗ 2106 движется
    ---------------------------------------------
    Функция car_base:
        Время выполнения - 0.20055059999999997 c
        Используемая память - 0.01171875 MiB
    ---------------------------------------------
    Лада Веста движется
    ---------------------------------------------
    Функция car_optimaze:
        Время выполнения - 0.2017645 c
        Используемая память - 0.0 MiB
    ---------------------------------------------
"""
# оптимизированный вариант выполняется с такой же скоростью,
# но использует в разы меньше памяти за счет использования слотов (__slots__ )


##################################### СКРИПТ 2 ########################################

@decor
def revers_base(m):     # рекурсивный метод "переворота" числа
    def reverse(n):
        return f'{n%10}' if n < 10 else f'{n%10}' + reverse(n//10)
    return reverse(m)


@decor
def revers_optimaze(n):     # оптимизирванный метод "переворота" числа
    return ''.join([i for i in str(n)[::-1]])


if __name__ == '__main__':
    a = 123456789012345678901234567890123456789012345678901234567890
    print(revers_base(a))
    print(revers_optimaze(a))

"""
вывод
    ---------------------------------------------
    Функция revers_base:
        Время выполнения - 0.20158859999999998 c
        Используемая память - 0.0703125 MiB
    ---------------------------------------------
    098765432109876543210987654321098765432109876543210987654321
    ---------------------------------------------
    Функция revers_optimaze:
        Время выполнения - 0.20180070000000006 c
        Используемая память - 0.0 MiB
    ---------------------------------------------
    098765432109876543210987654321098765432109876543210987654321
"""
# скорость выполнения одинаковая как у рекурсии так и у списка,
# но занимаемая память у списка (revers_optimaze) в разы меньше
# заодно выполнил task_3 )))


##################################### СКРИПТ 3 ########################################

@decor
def factorial_base(n):
    def factorial(n):
        if n == 0:
            return 1
        return factorial(n-1)*n
    return factorial(n)


@decor
def factorial_optimaze(n):
    def factorial(m, f=1):
        for i in range(1, m+1):
            f *= i
            yield f

    for i, f in enumerate(factorial(n), 1):
        if i == n:
            return f


if __name__ == '__main__':
    a = 990
    b = factorial_base(a)
    c = factorial_optimaze(a)

"""
вывод
    ---------------------------------------------
    Функция factorial_base:
        Время выполнения - 0.20534330000000003 c
        Используемая память - 1.34375 MiB
    ---------------------------------------------
    ---------------------------------------------
    Функция factorial_optimaze:
        Время выполнения - 0.20177130000000004 c
        Используемая память - 0.01953125 MiB
    ---------------------------------------------
"""

# и еще одна рекурсия, но оптимизация теперь при помощи генератора
# скорость работы функций не отличается, зато памяти генератор использует гораздо меньше
