"""
Задание 1.

Выполните профилирование памяти в скриптах.
Проанализируйте результат и определите программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.

Можно взять только домашние задания с курса Основ
или с текущего курса Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""

import memory_profiler
import time
from math import sqrt
from numpy import array
from sys import getsizeof

def my_decor(func):
    def wrapper(*args, **kwargs):
        m1, t1 = memory_profiler.memory_usage(), time.perf_counter()
        res = func(args[0])
        m2, t2 = memory_profiler.memory_usage(), time.perf_counter()
        mem_diff = m2[0] - m1[0]
        time_diff = t2 - t1
        return res, mem_diff, time_diff
    return wrapper


# 1 проверка. Алгоритмы по поиску простых чисел. Используем сито Эратосфена из заданий к 4 уроку и попытаемся
# оптимизировать его.
@my_decor
def sieve_erato_old(i):
    n = 2
    l = i * 12
    sieve = [x for x in range(l)]
    sieve[1] = 0
    while n < l:
        if sieve[n] != 0:
            m = n * 2
            while m < l:
                sieve[m] = 0
                m += n
        n += 1
    return [p for p in sieve if p != 0][i - 1]


@my_decor
def sieve_erato_new(i):
    simple_nums = []
    num = 2
    while i > len(simple_nums):
        is_simple = True
        for z in simple_nums:
            if z > sqrt(num):
                break
            if num % z == 0:
                is_simple = False
                break
        if is_simple:
            simple_nums.append(num)
        num += 1
    return simple_nums.pop()


# 2 Проверка. Алгоритмы по нахождению чисел Фиббоначи. С помощью рекурсии и с помощью массива, и с помощью переменных.

@my_decor
def fib_rec(n):
    return fib_rec1(n)

def fib_rec1(n):
    if n <= 1:
        return n
    return fib_rec1(n-1) + fib_rec1(n-2)


@my_decor
def fib_list(n):
    myl = [0, 1]
    for i in range(2, (n+1)):
        myl.append(myl[i-1] + myl[i-2])
    return myl.pop()

@my_decor
def fib_num(n):
    if n == 0:
        return 0
    a, b = 0, 1
    for i in range(n-1):
        a, b = b, a + b
    return b

if __name__ == '__main__':
    # 1. Проверка скриптов по вычеслению простых чисел. Ищем 10000-ое простое число.
    # Проверка sieve_erato_old()
    res, mem_dif, time_diff = sieve_erato_old(10000)
    print('Выполнение заняло {}  Mib памяти и {:.8} секунд времени.'.format(mem_dif, time_diff))
    # от (1.545 до 1.9296) mib и 0.1380584 сек
    del res, mem_dif, time_diff

    # Проверка sieve_erato_new()
    res, mem_dif, time_diff = sieve_erato_new(10000)
    print('Выполнение заняло {}  Mib памяти и {:.8} секунд времени.'.format(mem_dif, time_diff))
    del res, mem_dif, time_diff
    # в среднем 0.44 - 0.53 и 0.2723413 сек
    """
    В исполнении sieve_erato_old(i) превоначально создается огромный массив с числами, в котором в дальнейшем
    непростые заменяются нулями, и остаются только простые числа.
    В реализации sieve_erato_new(i) принцип решета используется лишь отчасти, вместо огромного списка всех чисел
    создается список, в который вносятся только простые числа, соответственно, он занимает гораздо меньше места в памяти.
    Тесты показывают, что вторая реализациия эффективнее использует память, однако проигрывает по времени.
    Первоначальный отрыв по времени на 10000 простом числе был более, чем в 10 раз:  sieve_erato_old - 0.13 сек
    и sieve_erato_new - 1.4 секнды. Однако с помощью еще одного условия прерывания цикла в момент, когда делитель 
    становится больше квадратного корня от проверяемого числа, отрыв свелся к минимуму.(0.13 против 0.27).
    Вывод: 1. Оптимизация выполнения программы в занимаемой ею памяти может совершенно не означать оптимизацию времени
    ее выполнения. 2. Благодоря аналитическому подходу получислось реализовать скрипт, который использует при выполнение
    гораздо меньший массив, из-за чего скрипт потребляет меньше памяти.
    
    """
    # 2. Проверка алгоритмов по нахождению чисел Фиббоначи.
    ## Проверка fib_rec(n)
    #res, mem_dif, time_diff = fib_rec(30)
    #print('Выполнение заняло {}  Mib памяти и {:.8} секунд времени.'.format(mem_dif, time_diff))
    # в среднем 0.0078125 mib и 20.929222 сек (именно для 30 числа)
    del res, mem_dif, time_diff

    ## Проверка fib_list(n)
    res, mem_dif, time_diff = fib_list(10000)
    print('Выполнение заняло {}  Mib памяти и {:.8} секунд времени.'.format(mem_dif, time_diff))
    # в среднем 0.42578125 и 0.1220863 сек
    del res, mem_dif, time_diff

    ## Проверка fib_num(n)
    res, mem_dif, time_diff = fib_num(10000)
    print('Выполнение заняло {}  Mib памяти и {:.8} секунд времени.'.format(mem_dif, time_diff))
    # в среднем 0.01953125 и 0.108691 сек
    del res, mem_dif, time_diff
    """
    В исполнеии fib_rec(n) число фиббоначи вычисляется с помощью рекурсивных вызовов. Однако уже вычисление даже 30 числа
    ни по каким показателям не может сраниться с конкурентами. 
    В реализации fib_list(n) создается список, при помощи которого вычисляются числа Фиббоначи.
    В реализации fib_num(n) используются только две переменные.
    Тесты показывают, что третья реализациия эффективнее использует память, и быстрее испоняется по времени.
    Вывод: рекурсивные функции выглядят эффектно и лаконично, однако зачастую являются не самыми оптимальными вариантами 
    реализации скриптов.
    Также, если в реализации скрипта можно обойтись без создания списка, следует обойтись без списка.
    """
    # 3 Проверка. Сравниваем размеры массивов, и смотрим, в каком типе оптимальнее хранить данные.
    myl = []
    for i in range(1000000):
        myl.append(i)

    nump = array(myl)
    print(f'Обычный list {getsizeof(myl)} байт.')
    # Обычный list 85176 байт. - на 10 000 элем
    # Обычный list 800984 байт. - на 100 000 элем
    # Обычный list 8448728 байт. - на 1 000 000 элем
    print(f'Массив numpy.array {getsizeof(nump)} байт.')
    # Массив numpy.array 40104 байт. - на 10 000 элем
    # Массив numpy.array 400104 байт. - на 100 000 элем
    # Массив numpy.array 4000104 байт. - на 1 000 000 элем
    """
    Вывод: разница между размерами используемой памяти между list и numpy.array практически чуть больше 50% процентов.
    Для хранения больших объемов данных оптимальнее изспользовать numpy.array.
    """
