"""
Задание 1.

Выполните профилирование памяти в скриптах.
Проанализируйте результат и определите программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.

Можно взять только домашние задания с курса Основ
или с текущего курса Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""
from memory_profiler import profile
from random import randint

# В классическом решении был обычный список, который я искуственно увеличил
print('*' * 100, 'Задача 1', '*' * 100)
print('Старое решение через список')
@profile
def a():
    prices = [randint(1, 100) for i in range(1000000)]
    format_prices = []
    for i in prices:
        i = str(i)
        if '.' in i:
            a = i.split('.')
            format_prices.append(f'{a[0]} руб. {int(a[1]):02} коп.')
        else:
            format_prices.append(f'{i} руб. 00 коп.')
    return ', '.join(format_prices)

a()

print('Новое решение через генератор')
# Создаем генератор для экономии памяти
def fill(numb):
    for i in numb:
        yield randint(1, 100)


@profile
def a():
    my_gen = tuple(fill(range(1000000)))
    format_prices = []
    for i in my_gen:
        i = str(i)
        if '.' in i:
            a = i.split('.')
            format_prices.append(f'{a[0]} руб. {int(a[1]):02} коп.')
        else:
            format_prices.append(f'{i} руб. 00 коп.')
    return ', '.join(format_prices)


a()

"""
В данном случае профилирование памяти заключается в замене списка, в котором хранятся данные на генератор.
Правда результаты работы @profile получаются сомнительные. Не смотря на то, что я заменил список из 1000000 элементов
генератором, profile показывает одинаковые результаты.
"""

print('*' * 100, 'Задача 2', '*' * 100)

print('Старое решение через рекурсию')


@profile
def sum_el(num, one):
    if num == 1:
        return one
    return sum_el(num - 1, one / -2) + one


user_number = int(input('Введите число: '))
print(f'Количество элементов: {user_number}, их сумма: {sum_el(user_number, 1)}')

print('Решение через цикл:')


@profile
def sum_el_new(num):
    res = 1
    a = res / -2
    for i in range(num - 1):
        res = res + a
        a = a / -2
    return res


user_number = int(input('Введите число: '))
print(f'Количество элементов: {user_number}, их сумма: {sum_el_new(user_number)}')

"""
Заменил рекурсию на цикл, что в теории должно экономить память. К сожалению, не знаю как усложнить данную
функцию для того, чтобы profile дал видимый результат.
"""
"""
К сожалению, пока понимание того, что и где можно улучшить дается очень туго. Это задание оказалось самым сложным из 
всего курса для меня. Просидел часов 20 перебирая все свои скрипты, но результата толком не дало.
В теории все понятно, и с заменой на кортежи и использованием встроенных функций и использование коллекций. На практике
пока идет туговато.
"""