"""
Задание 1.

Выполните профилирование памяти в скриптах.
Проанализируйте результат и определите программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.

Можно взять только домашние задания с курса Основ
или с текущего курса Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""
import json
from decorator import mem_time_decor
from pympler import asizeof

# ЗАДАЧА_1. Написать функцию thesaurus(), принимающую в качестве аргументов имена сотрудников и возвращающую
# словарь, в котором ключи — первые буквы имен, а значения — списки, содержащие имена, начинающиеся
# с соответствующей буквы. Например:
# >>> thesaurus("Иван", "Мария", "Петр", "Илья")
# {
#     "И": ["Иван", "Илья"],
#     "М": ["Мария"], "П": ["Петр"]
# }
# Замечание: Заранее неизвестно сколько фамилий передадут в функцию thesaurus
# Подумайте: полезен ли будет вам оператор распаковки? Сможете ли вы вернуть отсортированный по ключам словарь?
@mem_time_decor
def thesaurus_adv_1(*args):
    t_dict_adv = {}
    for name in args:
        n, s = name.split()
        if s[0] not in t_dict_adv:
            t_dict_adv[s[0]] = {n[0]: [name]}
        else:
            if n[0] not in t_dict_adv[s[0]]:
                t_dict_adv[s[0]][n[0]] = [name]
            else:
                t_dict_adv[s[0]][n[0]].append(name)
    print(t_dict_adv)
    return t_dict_adv

@mem_time_decor
def thesaurus_adv_2(*args):
    t_dict_adv = {}
    for name in args:
        n, s = name.split()
        if s[0] not in t_dict_adv:
            t_dict_adv[s[0]] = {n[0]: [name]}
        else:
            if n[0] not in t_dict_adv[s[0]]:
                t_dict_adv[s[0]][n[0]] = [name]
            else:
                t_dict_adv[s[0]][n[0]].append(name)
    json_dict = json.dumps(t_dict_adv)
    print(t_dict_adv)
    return json_dict


if __name__ == '__main__':
    thesaurus_adv_1('Клавдия Устинкова', 'Ольга Грыжина', 'Катерина Путренкова', 'Евгений Хабихолжин', 'София Зускова', 'Клавдия Спукаева', 'Геннадий Кукшкин', 'Лиза Санкова', 'Вера Татушкина', 'Олег Глобинов', 'Александр Чипилов', 'Валентин Дормаков', 'Иван Просянов', 'Федор Дрейсин', 'Роман Чекенев', 'Тарас Голошумов', 'Леонид Лапутенков', 'Иван Лебежихин', 'Аркадий Барлубаев', 'Мария Кириякина', 'Анна Деконова', 'Тарас Кученин', 'Аркадий Губедулин', 'Борис Золожков', 'Зинаида Цеунова', 'Алёна Быстцова', 'Альберт Иевский', 'Алина Арлачева', 'Алёна Манулова', 'Яков Саутиев', 'Иван Исайков', 'Светлана Гинтова', 'Ирина Камзолкина', 'Жанна Джаппуева', 'Степан Марташов', 'Евгения Жирзева', 'Роман Саманыкин', 'Игорь Елженков', 'Вера Дождалева', 'Валерий Прутский', 'Яков Шалапутин', 'Алина Полуэктова', 'Елизавета Жабанова', 'Софья Палькеева', 'Аркадий Которапов', 'Аркадий Вистицкий', 'Виктор Насибов', 'Кира Галохова', 'Вероника Шайцова', 'Анна Чепчина', 'Василий Ломакин', 'Виолетта Готманова', 'Пётр Балунин', 'Анна Бибарсова', 'Семён Лищишин', 'Степан Сопетин', 'Николай Саубанов', 'Борис Каценков', 'Пётр Довудов', 'Леонид Евсейкин', 'Кирилл Тарабрин', 'Галина Чириканова', 'Жанна Чугляева', 'Елена Муркина', 'Геннадий Кашкадов', 'Дарья Никитишина', 'Инна Дудочкина', 'Леонид Резников', 'Илья Навин', 'Мария Тавлинцева', 'Никита Рубанников', 'Григорий Нарочных', 'Евгения Бибердиева', 'Вероника Меренкова', 'Никита Заморев', 'Виктор Васин', 'Зинаида Кочегрова', 'Дарья Мушкеева', 'Кирилл Харбиков', 'Марина Шмакина', 'Лариса Рамакова', 'Инна Харалапова', 'Вероника Лемзакова', 'Степан Масянин', 'Маргарита Беловецкая', 'Любовь Шкабурова', 'Кристина Фролова', 'Дмитрий Друзьяков', 'Павел Арский', 'Леонид Румшинский', 'Вера Креслина', 'Виолетта Буртынкина', 'Виолетта Бойкина', 'Пётр Ладухин', 'Дарья Шурбенкова', 'Жанна Тяжлова', 'Дмитрий Тиунов', 'Леонид Зеничев', 'Артём Дрожжаков', 'Алексей Асаков')
    thesaurus_adv_2('Клавдия Устинкова', 'Ольга Грыжина', 'Катерина Путренкова', 'Евгений Хабихолжин', 'София Зускова', 'Клавдия Спукаева', 'Геннадий Кукшкин', 'Лиза Санкова', 'Вера Татушкина', 'Олег Глобинов', 'Александр Чипилов', 'Валентин Дормаков', 'Иван Просянов', 'Федор Дрейсин', 'Роман Чекенев', 'Тарас Голошумов', 'Леонид Лапутенков', 'Иван Лебежихин', 'Аркадий Барлубаев', 'Мария Кириякина', 'Анна Деконова', 'Тарас Кученин', 'Аркадий Губедулин', 'Борис Золожков', 'Зинаида Цеунова', 'Алёна Быстцова', 'Альберт Иевский', 'Алина Арлачева', 'Алёна Манулова', 'Яков Саутиев', 'Иван Исайков', 'Светлана Гинтова', 'Ирина Камзолкина', 'Жанна Джаппуева', 'Степан Марташов', 'Евгения Жирзева', 'Роман Саманыкин', 'Игорь Елженков', 'Вера Дождалева', 'Валерий Прутский', 'Яков Шалапутин', 'Алина Полуэктова', 'Елизавета Жабанова', 'Софья Палькеева', 'Аркадий Которапов', 'Аркадий Вистицкий', 'Виктор Насибов', 'Кира Галохова', 'Вероника Шайцова', 'Анна Чепчина', 'Василий Ломакин', 'Виолетта Готманова', 'Пётр Балунин', 'Анна Бибарсова', 'Семён Лищишин', 'Степан Сопетин', 'Николай Саубанов', 'Борис Каценков', 'Пётр Довудов', 'Леонид Евсейкин', 'Кирилл Тарабрин', 'Галина Чириканова', 'Жанна Чугляева', 'Елена Муркина', 'Геннадий Кашкадов', 'Дарья Никитишина', 'Инна Дудочкина', 'Леонид Резников', 'Илья Навин', 'Мария Тавлинцева', 'Никита Рубанников', 'Григорий Нарочных', 'Евгения Бибердиева', 'Вероника Меренкова', 'Никита Заморев', 'Виктор Васин', 'Зинаида Кочегрова', 'Дарья Мушкеева', 'Кирилл Харбиков', 'Марина Шмакина', 'Лариса Рамакова', 'Инна Харалапова', 'Вероника Лемзакова', 'Степан Масянин', 'Маргарита Беловецкая', 'Любовь Шкабурова', 'Кристина Фролова', 'Дмитрий Друзьяков', 'Павел Арский', 'Леонид Румшинский', 'Вера Креслина', 'Виолетта Буртынкина', 'Виолетта Бойкина', 'Пётр Ладухин', 'Дарья Шурбенкова', 'Жанна Тяжлова', 'Дмитрий Тиунов', 'Леонид Зеничев', 'Артём Дрожжаков', 'Алексей Асаков')
###############################################################################
# ЗАДАЧА_2. Реализовать класс Road (дорога).
# # определить атрибуты: length (длина), width (ширина);
# # значения атрибутов должны передаваться при создании экземпляра класса;
# # атрибуты сделать защищёнными;
# # определить метод расчёта массы асфальта, необходимого для покрытия всей дороги;
# # использовать формулу: длина * ширина * масса асфальта для покрытия одного кв. метра дороги асфальтом, толщиной
# # в 1 см * число см толщины полотна;
# # проверить работу метода.
# # Например: 20 м*5000 м*25 кг*5 см = 12500 т.
class Road_1:
    def __init__(self, length, width, asph_thickness):
        self._length = length
        self._width = width
        self.asph_mass = 25
        self.asph_thickness = asph_thickness

    def asphalt_mass(self):
        result = int(
            self._length * self._width * self.asph_mass * self.asph_thickness / 1000)
        return f'{result} т.'


r1 = Road_1(20, 5000, 5)
print(r1.asphalt_mass())
print(f'На выполнение кода потребовалось {asizeof.asizeof(r1)} MiB памяти')


class Road_2:
    __slots__ = ['_length', '_width', 'asph_mass', 'asph_thickness']

    def __init__(self, length, width, asph_thickness):
        self._length = length
        self._width = width
        self.asph_mass = 25
        self.asph_thickness = asph_thickness

    def asphalt_mass(self):
        result = int(
            self._length * self._width * self.asph_mass * self.asph_thickness / 1000)
        return f'{result} т.'


r2 = Road_2(20, 5000, 5)
print(r2.asphalt_mass())
print(f'На выполнение кода потребовалось {asizeof.asizeof(r2)} MiB памяти')
###############################################################################
# ЗАДАЧА_3. В программе генерируется случайное целое число от 0 до 100.
# Пользователь должен его отгадать не более чем за 10 попыток. После каждой
# неудачной попытки должно сообщаться больше или меньше введенное пользователем
# число, чем то, что загадано. Если за 10 попыток число не отгадано,
# то вывести загаданное число.
# Подсказка:
# Базовый случай здесь - угадали число или закончились попытки
# Решите через рекурсию. Решение через цикл не принимается.
# Для оценки Отлично в этом блоке необходимо выполнить 5 заданий из 7
import random


number = random.randint(0, 100)
print(number)

@mem_time_decor
def guess_num_1(num, count=10):
    congratulation = f'Поздравляем, вы угадали. Это было число {number}'
    regret = f'К сожалению, вы не угадали. Это было число {number}'
    while True:
        var_ = int(input(
            f'угадайте загаданное число от 0 до 100. У вас {count} попыток '))
        if count == 1:
            return regret
        elif var_ == num:
            return congratulation
        else:
            count -= 1


@mem_time_decor
def guess_num_2(num, count=10):
    congratulation = f'Поздравляем, вы угадали. Это было число {number}'
    regret = f'К сожалению, вы не угадали. Это было число {number}'
    var_ = int(input(f'угадайте загаданное число от 0 до 100. У вас {count} попыток '))
    count -= 1
    if var_ == num:
        return congratulation
    elif count == 1:
        return regret
    else:
        return guess_num_2(num, count)


print(guess_num_1(number))
print(guess_num_2(number))

'''
Начало: Создал mem_time_decor декоратор для дальнейшего ипмортирования, с целью 
измерения затраченных времери и памяти (модуль decorator.py).
Задача 1. Использование варианта сериализации. Объект Python - словарь 
t_dict_adv переводится в строку с помощью json.dumps. Результат:
- время выполнения с json осталось на прежнем месте.
- использование памяти значительно сократилось (стало 0.0078125 MiB против 
0.03515625 MiB со словарем).
Задача 2. Использование слотов в ООП. Поместил атрибуты экземпляра класса в 
слоты. Результат:
- время выполнения не исследовал. Объективно, сократиться не должно.
- использование памяти значительно сократилось (стало 192 MiB против 
520 MiB без слотов).
Задача 3. Использование цикла вместо рекурсии. 
Результат:
- время выполнения функции значительно быстрее в цикле. 
- полноценно замерить память, затраченную на рекурсию проблематично, так как 
оценивается каждый шаг рекурсии. Следовательно, точно сравнить не смог. Но, 
по приблизительным подсчетам, цикл быстрее рекурсии.
'''
