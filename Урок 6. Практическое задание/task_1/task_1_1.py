"""
Задание 1.

Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.

Можно взять задачи с курса Основ
или с текущего курса Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""

'''
Первый скрипт - «Решето Эратосфена»
'''

import memory_profiler
import time
from numpy import array  # !!!
from recordclass import recordclass



def decor(func):
    def wrapper(*args, **kwargs):
        m1 = memory_profiler.memory_usage()
        t1 = time.time()
        res = func(args[0])
        t2 = time.time()
        m2 = memory_profiler.memory_usage()
        mem_diff = m2[0] - m1[0]
        return res, mem_diff, t2-t1
    return wrapper

@decor
def sieve_1(n):
    # словарь некоторых ранее рассчитаных значений n-элемента (требуемой длины списка)
    dict_result = {10: 29, 100: 541, 1000: 7919, 5000: 48611, 10000: 104729, 20000: 224737,30000: 350377, 40000: 479909,
                    50000: 611953, 60000: 746773, 70000: 882377, 80000: 1020379, 90000: 1159523, 100000: 1299709}
    len_list = 0
    for key, value in dict_result.items():
        if n <= key:
            len_list = value + 1
            break
    if len_list == 0:           # не входит в интервал (не считали требуемую длину списка)
        return sieve_2(n)       # считаем "медленным", но экономным по памяти методом
    # список заполняется значениями от 0 до len_list
    a = [x for x in range(len_list)]
    a[1] = 0
    i = 2                   # начинаем с 3-го элемента
    while i < len_list:
        if a[i] != 0:
            j = i + i
            while j < len_list:
                a[j] = 0
                j = j + i
        i += 1
    a = set(a)  # избавляемся от всех нулей кроме одного
    a.remove(0)             # удаляем ноль
    a = sorted(a)[0:n]      # обрежем "лишние" найденные простые числа, можно было просто вернуть n-й элемент
    return a[-1]            # вернем максимальный

@decor
def sieve_2(n):
    """c использованием «Решета Эратосфена»"""
    primes = [2, 3]                             # !!! O(1)  Первые простые числа
    candidate = 3                               # !!! O(1)  Кандидат на простое число (присвоим последнему из простых)
    while len(primes) < n:                      # !!! O(n)  Перебираем, пока не наберем нужное количество простых
        candidate += 2                          # !!! O(1)  Не учитываем все четные (ускорение пеербора в два раза)
        is_simple = True                        # !!! O(1)
        for el in primes:                       # !!! O(n)  Переберем все ранее найденные простые
            if candidate % el == 0:             # !!! O(1)  Попробуем на них поделить
                is_simple = False               # !!! O(1)  если делится, значит не простое
                break                           # !!! O(1)
        if is_simple:                           # !!! O(1)  если все перебрали и не нашли делитель
            primes.append(candidate)            # !!! O(1)  значит, это простое - добавим в наш массив
    return primes[-1]                           # !!! O(1)  вернуть последнее простое


@decor
def sieve_1_2(n):
    # словарь некоторых ранее рассчитаных значений n-элемента (требуемой длины списка)
    dict_result1 = {10: 29, 100: 541, 1000: 7919, 5000: 48611, 10000: 104729, 20000: 224737,30000: 350377, 40000: 479909,
                    50000: 611953, 60000: 746773, 70000: 882377, 80000: 1020379, 90000: 1159523, 100000: 1299709}
    len_list = 0
    for key, value in dict_result1.items():
        if n <= key:
            len_list = value + 1
            break
    if len_list == 0:           # не входит в интервал (не считали требуемую длину списка)
        return sieve_2(n)       # считаем "медленным", но экономным по памяти методом
    # список заполняется значениями от 0 до len_list
    a = array([x for x in range(len_list)])
    a[1] = 0
    i = 2                   # начинаем с 3-го элемента
    while i < len_list:
        if a[i] != 0:
            j = i + i
            while j < len_list:
                a[j] = 0
                j = j + i
        i += 1
    a = set(a)  # избавляемся от всех нулей кроме одного
    a.remove(0)             # удаляем ноль
    a = sorted(a)[0:n]      # обрежем "лишние" найденные простые числа, можно было просто вернуть n-й элемент
    return a[-1]            # вернем максимальный

'''
функция-генератор простых чисел primes
'''
def primes():
    i = 1
    while True:
        i += 1
        count = 1   # делится на 1
        for x in range(2, i):
            if i % x == 0:
                count += 1
                break
        else:
            yield i

@decor
def sieve_2_2(n):
    l = list(zip(range(n), primes()))
    return l[n-1][1]

# =============================================

number = 10000
print(f'Рассмотрим два варианта ревлизации "Решета Эратосфена" при поиске {number}-ого элемента.')
res, mem_diff1, time_diff1 = sieve_1(number)
print(f"Выполнение первого варианта заняло {mem_diff1} Mib, {time_diff1} времени.")
res, mem_diff2, time_diff2 = sieve_2(number)
print(f"Выполнение варианта заняло {mem_diff2} Mib, {time_diff2} времени.")
print(f"Таким образом, второй вариант на {int(abs(mem_diff2-mem_diff1)/mem_diff1*100)}% менее требовательный "
      f"по памяти, но в {int(time_diff2/time_diff1)} раз(а) медленнее по скорости.")
res, mem_diff2, time_diff2 = sieve_1_2(number)
print(f"Выполнение первого варианта, после оптимизации заняло {mem_diff2} Mib, {time_diff2} времени.")
res, mem_diff2, time_diff2 = sieve_2_2(number)
print(f"Выполнение второго варианта, после оптимизации заняло {mem_diff2} Mib, {time_diff2} времени.")

'''
Рассмотрим два варианта ревлизации "Решета Эратосфена" при поиске 10000-ого элемента.
Выполнение первого варианта заняло 0.58984375 Mib, 0.07200407981872559 времени.
Выполнение варианта заняло 0.19921875 Mib, 4.429111480712891 времени.
Таким образом, второй вариант на 66% менее требовательный по памяти, но в 61 раз(а) медленнее по скорости.
Выполнение первого варианта, после оптимизации заняло 0.328125 Mib, 0.18907880783081055 времени.

Первый алгоритм «Решета Эратосфена» использует "большой" список для записи всех чисел из интервала от 0 до искомого.
Более того, этот алгоритм "не очень" точно определяет, какой размерности этот список делать, ориентируясь на 
словарь с предварительными интервалами. Но, этот алгоритм имеет линейную сложность и поэтому достаочно быстр.
Второй алгоритм перебирает все числа последовательно, строя список из "простых" чисел. 
Основным принципом выигрыша по памяти этого варианта можно считать "алгоритмический" (минимум вспомогательных массивов) 
С т.з. памяти, мы можем оптимизировать оба алгоритма, но сконцентрируемся на первом (как более затратном).
Вместо обычного списка, используем array из numpy. Это позволило нам сократить требования по памяти в 2 раза!!!
Правда, и по скорости, алгоритм работает в 2 раза медленеее, но это не в 60 раз, как второй!!!

Заметил, что при запуске последовательно различных алгоритмов, если показания затрат по времени более менее идентичные
у одного и того-же алгоритма, то показатели памяти начинают "врать". 
Пэтому, для чистоты эксперимента, модифицированный алгоритм запускал по "отдельно".  
   
'''