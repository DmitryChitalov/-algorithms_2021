"""
Задание 2.*
Предложить еще какие-либо варианты (механизмы, подходы, библиотеки, идеи)
для оптимизации памяти и
доказать!!! (наглядно, кодом) их эффективность (на примере профилировщика).
"""


"""
Дополнительные варианты оптимизации памяти я нашла, а вот с доказательствами - не
вышло. Но т.к. время на поиски и изучение информации было потрачено, помещу их в
качестве хотя бы такого ответа на задание.

1. Cython, который позволяет использовать функции и методы С и С++ для нужд Python.
Не подходит для небольших скриптов, но способен значительно уменьшить затраты памяти
в случае объемных. Требует строгой типизации объектов (классов, переменных) - если
это не выполнить, преимуществ использование Cython не даст.

Я попыталась использовать этот метод на практике, создав файл-модуль cython_data.pyx,
но мне почему-то не удалось его запустить (пробовала 3 вариантами), на этапе компиляции
происходит вызов ошибки, а для ее решения требуется visual C++ 2008, который не хочет
ставиться на мою машину. Поэтому наглядно я доказать преимущество Cython не смогу.

import pyximport

pyximport.install()
import cython_code.cython_data as cython_data


if __name__ == '__main__':
   my_new_obj = cython_data.Date('14-12-2001') 
   
Cython-файл:
# cython: language_level=3
cdef class CythonShopClass:
   cdef str date_str

   def __init__(self, str date_str):
        tmp_data = self.get_elements(date_str)
        self.date_str = tmp_data

   cdef str get_elements(date_str):
        cdef int i
        cdef list result
        cdef str date_str
        result = [int(i) for i in date_str.split('-')]
        return result

2. Интерпретатор Python PyPy, в котором используется JIT-компилятор. Он может
выделить часто используемые операции и оптимизировать их, скомпилировав в машинный
код. Также делает более эффективной работу сборщика мусора - он задействуется поэтапно,
а не полным проходом по всему коду за раз. Такой подход позволяет дополнительно
сэкономить память.
Про него я успела только почитать и скачать.
"""