"""
Задание 1.

Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.

Можно взять только домашние задания с курса Основ
или с текущего курса Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""

"""
Найти сумму n элементов следующего ряда чисел: 1 -0.5 0.25 -0.125 ...

"""

from memory_profiler import profile


# решение с рекурсией,до оптимизации
@profile
def sum_row(my_number, n):
    if n > 1:
        return my_number + sum_row(my_number / -2, n - 1)
    else:
        return my_number


# решение с циклом, после оптимизации
@profile
def sum_row2(my_number, n):
    s = 0
    while n > 0:
        s += my_number
        my_number = my_number / -2
        n -= 1
    return s


n = 50

print(sum_row(1, n))
print(sum_row2(1, n))

"""

Ниже приведены замеры для одного вызова с рекурсией и для варианта с циклом
При использовании рекурсии память в объеме 16.2 MiB выделяется при каждом вызове функции по-новой.
При реализации с циклом память выделяется однократно.
Соответственно, решение с циклом занимает меньше памяти.


Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
    34     16.2 MiB     16.2 MiB           1   @profile
    35                                         def sum_row(my_number, n):
    36     16.2 MiB      0.0 MiB           1       if n > 1:
    37                                                 return my_number + sum_row(my_number / -2, n - 1)
    38                                             else:
    39     16.2 MiB      0.0 MiB           1           return my_number



Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
    42     16.2 MiB     16.2 MiB           1   @profile
    43                                         def sum_row2(my_number, n):
    44     16.2 MiB      0.0 MiB           1       s = 0
    45     16.2 MiB      0.0 MiB          51       while n > 0:
    46     16.2 MiB      0.0 MiB          50           s += my_number
    47     16.2 MiB      0.0 MiB          50           my_number = my_number / -2
    48     16.2 MiB      0.0 MiB          50           n -= 1
    49     16.2 MiB      0.0 MiB           1       return s

"""
