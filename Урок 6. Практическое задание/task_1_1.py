"""
Задание 1.

Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.

Можно взять только домашние задания с курса Основ
или с текущего курса Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""

from memory_profiler import profile


# Сформировать из введенного числа обратное по порядку входящих в него
# цифр и вывести на экран. Например, если введено число 3486,
#  то надо вывести число 6843.


# решение с рекурсией,до оптимизации
@profile
def reverse_number1(my_number):
    if my_number >= 10:
        return str(my_number % 10) + reverse_number1(my_number // 10)
    else:
        return str(my_number)


# решение с циклом, после оптимизации
@profile
def reverse_number2(my_number):
    s = ""
    while my_number > 0:
        s += str(my_number % 10)
        my_number = my_number // 10
    return s


n = 3209480128754387349857298743589747943574538979888

print(reverse_number1(n))
print(reverse_number2(n))

"""

Ниже приведены замеры для одного вызова с рекурсией и для варианта с циклом
На первый взгляд, объем используемой памяти одинаковый -16.2, но при рекурсии она выделяется в таком объеме
при каждом вызове (формируется стек вызовов).

При реализации с циклом память выделяется однократно.

Соответственно, вариант с циклом потребляет меньше памяти.
  

Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
    34     16.2 MiB     16.2 MiB           1   @profile
    35                                         def reverse_number1(my_number):
    36     16.2 MiB      0.0 MiB           1       if my_number >= 10:
    37                                                 return str(my_number % 10) + reverse_number1(my_number // 10)
    38                                             else:
    39     16.2 MiB      0.0 MiB           1           return str(my_number)
    
    
Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
    43     16.2 MiB     16.2 MiB           1   @profile
    44                                         def reverse_number2(my_number):
    45     16.2 MiB      0.0 MiB           1       s = ""
    46     16.2 MiB      0.0 MiB          50       while my_number > 0:
    47     16.2 MiB      0.0 MiB          49           s += str(my_number % 10)
    48     16.2 MiB      0.0 MiB          49           my_number = my_number // 10
    49     16.2 MiB      0.0 MiB           1       return s


"""
