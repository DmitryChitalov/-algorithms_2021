"""
Задание 1.

Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.

Можно взять только домашние задания с курса Основ
или с текущего курса Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""
from decor import decor

"""
Задачи из основ Питона
Задача №3 из 4 урока
Для чисел в пределах от 20 до 240 найти числа, кратные 20 или 21. 
Подсказка: использовать функцию range() и генератор.
"""

# Изначальный вариант
@decor
def get_number():
    my_result = [i for i in range(20, 1000000) if i % 20 == 0 or i % 21 == 0]
    return my_result


# Оптимизированый вариант
@decor
def get_number_1(numbers):
    for i in numbers:
        if i % 20 == 0 or i % 21 == 0:
            yield i

get_number()
my_generator = get_number_1(list(range(20, 1000000)))
print(type(my_generator))

"""
Время работы функции get_number, составило: 0.29114360 сек.
Выполнение функции get_number, заняло: 3.91015625 Mib.
Время работы функции get_number_1, составило: 0.00001640 сек.
Выполнение функции get_number_1, заняло: 0.0 Mib.
<class 'generator'>
Увеличел количесто элементов, для улучшение статистики.
Через генератор, время выполнения уменшилось очень на много и памяти стало занимать менее 1 Mib. 
"""