from memory_profiler import memory_usage

"""
Задекорировал рекурсивную функцию так, чтобы при каждом 
ее вызове показывалось текущее состояние памяти.
Для того, чтобы было явно видно изменение в памяти 
при каждом рекурсивном вызове, добавил вычисление
[el for el in range(10 ** 6)] как эмуляцию нагрузки 
на память при работе на данном вызове.
Таким образом можно отследить расход памяти на каждый 
вызов без отдельной таблицы по каждому вызову.
Решение не самое красивое, но рабочее. Придумал его сам, 
в гугле найти не смог ничего явно подходящего для этой задачи.
"""

user_number = int(input('Введите целое положительное число: '))
lst = []  # будет хранить значения задействуемой
                                    # памяти при каждом рекурсивном вызове


def mem_usage_decorator(some_func):
    """Вычисляет память, выделяемую под выполнение декорируемой функции"""

    def wrapper(*args, **kwargs):
        result = some_func(*args, **kwargs)
        lst.append(str(memory_usage()))  # добавляем в список
                                        # значение задействованной памяти
        return result

    return wrapper


@mem_usage_decorator
def fact(number):
    """Вычисляет факториал числа"""
    if number == 1:
        return 1
    else:
        _ = [el for el in range(10 ** 6)]  # добавляем затратные
                                    # для памяти вычисления для тестирования
        return number * fact(number - 1)


print(f'Задействованная память до запуска рекурсивной функции: '
      f'{str(memory_usage())} MB')
print(f'Факториал числа: {fact(user_number)}')

for i, memory in enumerate(list(reversed(lst)), 1):
    print(f'Задействованная память после рекурсивного вызова '
          f'{i}-й раз: {memory} MB')
