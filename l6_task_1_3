from memory_profiler import memory_usage, profile
from timeit import default_timer


def mem(func):
    def my_func(*args, **kwargs):
        start = default_timer()
        memory = memory_usage()
        result = func(*args, **kwargs)
        print(f'Используемая память {memory_usage()[0] - memory[0]}\nВремя выполнения: {default_timer() - start}')
        return result

    return my_func


print(f'Профилировка обычных функций:\n')
num = list(range(1, 1000000))


@mem
def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


@mem
def func_2(nums):
    return [i for i in range(len(nums)) if nums[i] % 2 == 0]


@mem
def func_3(nums):
    return [i for i, v in enumerate(nums) if v % 2 == 0]


@mem
def func_4(nums):
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            yield i


func_1(num)
func_2(num)
func_3(num)
func_4(num)

print(f'{"#" * 50}\nПрофилировка рекурсии:\n')

number = 3


@mem
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)


@mem
def factorial_gen(n):
    if n == 0:
        yield 1
    else:
        for i in factorial_gen(n - 1):
            yield i * n


factorial(number)
print(f'\nСпособ оптимизации, рекурсия:\n')
factorial_gen(number)
print(f'\nРекурсивный генератор вывод:\n')
print(next(factorial_gen(number)))
print(f'{"#" * 50}\nВариант профилировки полностью рекурсии:\n')


@mem
def recur(a, b=''):
    def rec(x=a, y=b):
        if not x:
            return [y]
        else:
            ret = []
            for i in range(len(x)):
                ret += rec(x[:i] + x[i + 1:], y + x[i])
        return ret

    return rec(x=a, y=b)


recur('abcdefghijk')

print(f'\nРекурсия yield:\n')
@mem
def gen(x, y=''):
    if not x:
        yield y
    else:
        for i, j in enumerate(x):
            yield from gen(x[:i] + x[i + 1:], y + j)


gen('abcdefghijk')

"""
Профилировка обычных функций:

При профилировки памяти и времени обычных функций мы можем наблюдать выделения памяти при их выполнении за 
исключением использования в функции генератора. Это обусловлено тем что yield возвращает только одно значение из 
последовательности и не хранит в памяти всю последовательность.

Используемая память 20.7734375
Время выполнения: 0.2810012
Используемая память 18.15625
Время выполнения: 0.27627090000000004
Используемая память 19.98046875
Время выполнения: 0.2745978
Используемая память 0.0
Время выполнения: 0.21278150000000007
##################################################
Профилировка рекурсии:

При профилировки рекурсии мы видим значения каждого 
вызова функции.

Используемая память 0.0
Время выполнения: 0.21855289999999994
Используемая память 0.0
Время выполнения: 0.43469789999999997
Используемая память 0.0
Время выполнения: 0.6503853000000002
Используемая память 0.0
Время выполнения: 0.8683417

Способ оптимизации, рекурсия:

Способом оптимизации данного скрипта я выбрал аналогичную рекурсию только с использованием 
генератора, как можно наблюдать вывод профилировки обусловился единичными показателями памяти и времени, 
что отличается от аналогичной рекурсии выше.

Используемая память 0.0
Время выполнения: 0.21476220000000001

Рекурсивный генератор вывод:

Однако если мы сделаем вывод значения рекурсивного генератора то мы 
видим аналогичное кол-во отображений поазателей.

Используемая память 0.0
Время выполнения: 0.21703070000000002
Используемая память 0.0
Время выполнения: 0.2156205
Используемая память 0.0
Время выполнения: 0.2166676999999999
Используемая память 0.0
Время выполнения: 0.2148504
6
##################################################
Замеры рекурсий показывают разницу во времени в пользу генератора, 
но не по использованной памяти, чтобы убедиться в эффективности и оптимизации процесса с использованием рекурсивного 
генератора поместим рекурсию в функцию чтобы получить полноту картины по использованию памяти и затрат времени и 
аналогичный скрипт с использованием рекурсии и генератора.

Вариант профилировки полностью рекурсии:

Используемая память 2779.625
Время выполнения: 43.1691103

Рекурсия yield:

Используемая память 0.0
Время выполнения: 0.2225988000000001

Из приведенных чисел мы видим насколько эффективно работает генератор.
"""
