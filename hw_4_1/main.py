"""
Задание 1.
Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива
Сделайте замеры времени выполнения кода с помощью модуля timeit
Оптимизируйте, чтобы снизить время выполнения
Проведите повторные замеры.
Добавьте аналитику: что вы сделали и почему!!!
Без аналитики задание не принимается
И прошу вас обратить внимание, что то, что часто ошибочно называют генераторами списков,
на самом деле к генераторам отношения не имеет. Это называется "списковое включение" - list comprehension.
"""
import timeit
from timeit import default_timer as start

def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr

###########
def func_2(nums):
    new_arr_2 = [i for i in nums if i % 2 == 0]
    return new_arr_2

list_1 = [1, 2, 3, 4, 5, 6]

print(min(timeit.repeat("func_2(list_1)", globals=globals(), timer=start , number=100000)))
print(min(timeit.repeat("func_1(list_1)", globals=globals(), timer=start , number=100000)))

# Итог, так как генератор не создает большую структуру данных в памяти, а вместо этого возвращает итерацию,
# то и тратится меньше времени, и памяти. Плюс я заранее не создал пустой список, и не делал аппенды