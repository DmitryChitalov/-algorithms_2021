"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать, так и отли-
   чаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.
   Операцию clear() не используем.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!

Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""

import random


# функция обертка для измерения времени
def time_check(func):
    import time

    def wrapper():
        start = time.time()
        func()
        end = time.time()
        print(f'Время выполнения {func.__name__}: '
              f'{end - start}')

    return wrapper


need_dict = {}
need_list = []


# заполнение словаря
@time_check
def fill_dict():  # O(1)
    for el in range(100000):  # O(1)
        need_dict[el + 1] = el  # O(1)


fill_dict()  # Время на выполнение: 0.00800180435180664


# заполнение списка
@time_check
def fill_list():  # O(1)
    for el in range(100000):  # O(1)
        need_list.append(el)  # O(1)


fill_list()  # Время на выполнение: 0.005001068115234375

"""
Делаем вывод что операция заполнения списка идет быстрее (несмотря на одинаковую сложность) видимо из-за простоты
списка как объекта
"""


# Следующие две ф-ции для выбора случайного элемента с импортом random
@time_check
def random_elem_list():  # O(1)
    random.choice(need_list)


random_elem_list()  # Время выполнения: 0.0


@time_check
def random_elem_dict():  # O(1)
    random.choice(list(need_dict.items()))


random_elem_dict()  # Время выполнения: 0.006002187728881836


# Удаление всех элементов из словаря
@time_check
def dict_delete_elems():  # O(1)
    for el in range(len(need_dict)):
        need_dict.pop(el + 1)


dict_delete_elems()  # Время выполнения: 0.01100301742553711


# Удаление всех элементов из списка
@time_check
def list_delete_elems():  # O(1)
    for el in range(len(need_list)):
        need_list.pop()


list_delete_elems()  # Время выполнения: 0.00400090217590332

"""
Вывод: в данных одинаковых операциях с одинаковой сложностью список выигрывает по скорости из-за своей простоты
"""
