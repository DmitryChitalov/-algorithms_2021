"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать, так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.
   Операцию clear() не используем.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!

Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""
from time import time
import random

my_lst = []
my_dict = {}
n = 100000

def fill_lst_append(n):
    start = time()
    for i in range(n):
        my_lst.append(i)
    end = time()
    return f'Заполнение списка {n} эл-ми методом append выполнено за {end - start} сек'

print(fill_lst_append(n))

def fill_lst_insert(n):
    start = time()
    for i in range(n):
        my_lst.insert(0, i)         # O(n)
    end = time()
    return f'Заполнение списка {n} эл-ми методом insert выполнено за {end - start} сек'

print(fill_lst_insert(n))

def fill_dict(n):
    start = time()
    for i in range(n):
        my_dict[i] = i
    end = time()
    return f'Заполнение словаря {n} эл-ми выполнено за {end - start} сек'

print(fill_dict(n))

def remove_lst(lst):
    start = time()
    for i in range(len(lst)):       # O(n)
        lst.pop()                   # O(1)
    end = time()
    return f'Удаление всех эл-ов (лин-ая сложн) из списка заняло {end - start} сек'

def remove_lst_(lst):
    l = len(lst)
    start = time()
    for i in range(l):       # O(1)
        lst.pop(i)           # O(1)
    end = time()
    return f'Удаление всех эл-ов (конст. сложность) из списка заняло {end - start} сек'

print(remove_lst(my_lst))
print(remove_lst_(my_lst))

def remove_dict(dct):
    start = time()
    for i in range(len(dct)):   # O(n)
        dct.popitem()           # O(1)
    end = time()
    return f'Удаление всех эл-ов из словаря (лин. сложн.)заняло {end - start} сек'

def remove_dict_(dct):
    n = len(dct)
    start = time()
    for i in range(n):          # O(1)
        dct.popitem()           # O(1)
    end = time()
    return f'Удаление всех эл-ов из словаря (конст. сложн.) заняло {end - start} сек'

print(remove_dict(my_dict))
print(remove_dict_(my_dict))

""" 
Вывод: 
Заполнение списка 100000 эл-ми методом append выполнено за 0.02450084686279297 сек
Заполнение списка 100000 эл-ми методом insert выполнено за 25.99947714805603 сек
Заполнение словаря 100000 эл-ми выполнено за 0.02499842643737793 сек
Удаление всех эл-ов (лин-ая сложн) из списка заняло 0.023514270782470703 сек
Удаление всех эл-ов (конст. сложность) из списка заняло 0.0 сек
Удаление всех эл-ов из словаря заняло 0.01548624038696289 сек
Удаление всех эл-ов из словаря (конст. сложн.) заняло 0.0 сек

метод append имеет конст. сл. в отличие от insert, которая имеет сложность O(n)
соотв-но создание списка происходит во втором случае гораздо дольше и это 25 сек, что 
очень долго. А вот создать список и словарь в обоих случаях O(1) разницы почти нет, 
плюс-минус одно и тоже время. Далее я реализовал удаление эл-ов из списка и словаря,
сделав это алг-ми с O(n) и O(1). Как видно конст. сл. выполняется моментально, а в случае
с лин. сл. требуется немного времени, зависит от объема вх. данных. Но во всех случаях,
по крайне мере у меня удаление эл-ов из словаря происходит чуть быстрее, не смотря, что 
оба варианта имеют сложность O(n)
"""

