"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря программно,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!
"""

import time as t


def time_decorator(function):
    """Декоратор на подсчет времени выполнения"""

    def timer(n):
        a = t.time()
        r = function(n)
        print(f'Время выполнения: {t.time() - a}')
        return r

    return timer


@time_decorator
def gen_list(n):
    """Наполняем список с помощью списковое включение"""
    print('Генератор списка')
    result = [i for i in range(n)]
    return result


@time_decorator
def cycle_list(n):
    """Наполняем список циклом"""
    print('Список с помощью цикла')
    result = []
    for i in range(n):
        result.append(i)
    return result


@time_decorator
def gen_dict(n):
    """Наполняем словарь списковое включение"""
    print('Генератор словоря')
    result = {i: i for i in range(n)}
    return result

@time_decorator
def cycle_dict(n):
    """Наполняем словарь циклом"""
    print('Словарь с помощью цикла')
    result = {}
    for i in range(n):
        result.update({i: i})
    return result


@time_decorator
def pop_list(n):
    """Удаление списка по индексу"""
    print('Удаляется список по индексам')
    for i in range(len(n)):
        n.pop(0)  # 0 индекс так как i будет рости а список уменьшаться,
        # а если без индекса то не так очевидно будет сровнение с словарем так как
        # удаляетя последний элемент быстрее чем проидексированный
    return n


@time_decorator
def pop_dict(n):
    """Удаляем словарь по ключам"""
    print('Удаляем словарь по ключам')
    for i in range(len(n)):
        n.pop(i)
    return n


@time_decorator
def clear_list_dict(n):
    """Очищение списка или словаря """
    n.clear()


@time_decorator
def copy_list_dict(n):
    """Копирование списка или словаря"""
    n.copy()


@time_decorator
def insert_middle_list(n):
    """Добовление в середину списка """
    print('Добовление в середину списка')
    for i in range(500):
        n.insert((len(n) // 2), 'Элемент')


@time_decorator
def update_dict(n):
    """Обновление словоря по индексу len(n)//2+(i*2) примерно с середины"""
    print('Обновление словоря с середины списка')
    for i in range(500):
        n.update({(len(n) // 2 + (i * 2)): 'Обновлено'})


n = 500000
a = gen_list(n)  # +- 0,024
b = cycle_list(n)  # +- 0,036
c = gen_dict(n)  # +- 0,038
d = cycle_dict(n)  # +- 0,078
# Как видим список наполняется быстрее словоря а списковое включение работают быстрее простого цикла
# И списковое включение словоря почти так же быстр как наполнение списка циклом
# Словарь наполняется дольше так как надо создавать хэш таблицу в отличии от списка
insert_middle_list(a)  # +- 0.049
update_dict(c)  # +- 0,00099
print('Копия лист')
copy_list_dict(a)  # +- 0.0049
print('Копия словарь')
copy_list_dict(c)  # +- 0.0099
print('Очистка лист')
clear_list_dict(a)  # +- 0.0039
print('Очистка словарь')
clear_list_dict(c)  # +- 0.0059
pop_list(b)  # +- 35.91
pop_dict(d)  # +- 0.040
# Все что косается создание  копирование очистки выполняется быстрее в списках
# Все что косается обновление(середины словоря) удаление по индексу да и доступы по индексам(ключам)
# выполняется быстрее в словорях
# Так как словари это хэш таблицы доступы к данным будут осуществляться быстрее в словорях
# но их создание требует времени


