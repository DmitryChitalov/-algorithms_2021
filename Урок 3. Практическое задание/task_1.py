"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать,
    так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.
   Операцию clear() не используем.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!

Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""
import time


# Complexity o(n)
def decor(func):
    def wrap(x):
        start = time.time()
        func(x)
        return time.time() - start
    return wrap


# Complexity O(n)
@decor
def func_list(x, list_x=[]):
    for i in range(1, x+1):
        list_x.append(i)


# Complexity O(n)
@decor
def func_dict(x, dict_x={}, y=0):
    for i in range(1, x+1):
        dict_x[y] = i
        y += 1


# Complexity O(n)
def func_dict_x(x, dict_x={}, y=0):
    for i in range(1, x+1):
        dict_x[y] = i
        y += 1
    return dict_x


# Complexity O(n)
def func_list_x(x, list_x=[]):
    for i in range(1, x+1):
        list_x.append(i)
    return list_x


# Complexity O(n)
@decor
def func_pop(list_x):
    while list_x != []:
        list_x.pop()


# Complexity O(n)
@decor
def func_popitem(dict_x):
    while dict_x != {}:
        dict_x.popitem()


if __name__ == '__main__':
    print(func_list(1000000))
    print(func_dict(1000000))
    print(func_pop(func_list_x(1000000)))
    print(func_popitem(func_dict_x(1000000)))

# По данным замерам  операции со словарями проходят примерно 30% дольше чем со словарями
# думаю что разница иза того что структура списка придусматривает индексацию
# а в словорях индексация значений происходит не автоматически иза этого нужно проверять ключи на уникальность

