"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать, так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.
   Операцию clear() не используем.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!

Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""
import time


def speed_decor(func):
    def speed(content=None):
        start = time.time()
        if content:
            print('Время на создание списка и словаря')
            func(content)
        else:
            print('Время на вставку, получение и удаление элементов')
            func()
        end = time.time()
        print(end - start)
        return func

    return speed


# -------------------------A-----------------------------
@speed_decor
def lst_fill(content):
    a = [i for i in content]
    return a  # Сложность функцмм линейная O(N), т.к. зависит от величины диапозона range


some_lst = lst_fill(range(100000))


@speed_decor
def dict_fill(content):
    return {i: None for i in content}  # Сложность так же зависит от range, поэтому О(N)


some_dict = dict_fill(range(100000))
# print(type(some_dict))

"""
Вывод: словарь заполняется медленнее. Думаю из-за того, что 1 - необходимо время на генерацию и вставку не только ключа, 
но и значения этого ключа 2 - видимо затрачивается время на вычисление генерацию ХЭШей для ключей.
"""

# -------------------B-------------------
b = list(some_lst(range(10000000)))
c = dict(some_dict(range(10000000)))


@speed_decor
def lst_operation():               # Общая сложность O(N)
    b.append(123456789)
    some_value = b[55]
    del b[100]


lst_operation()


@speed_decor
def dict_operation():           # Общая сложность O(1)
    c['a'] = None
    some_value = c['a']
    del c['a']


dict_operation()

"""
Вывод: сколько бы элементов в словаре не было, при работе с его элементами время уверенно стоит на 0. В отличие от 
работы с элементами списка. Можно сделать вывод, что работа с данными словаря идет быстрее. Мне кажется потому, что
при работе со списком интерпритатор перебирает по очереди каждый элемент списка, чтобы добраться до нужного. А в словарь
устроен так, что есть доступ непосредственно к запрашиваемому элементу (что-то вроде интексов в mysql).
"""