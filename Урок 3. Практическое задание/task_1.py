"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать,
   так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!

Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""


import time

n = 10 ** 5


def benchmark(func):

    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print('[*] Время выполнения: {} секунд.'.format(end - start))
        return result

    return wrapper


@benchmark
def filling_d(some_obj, n):      # Сложность O(n)
   for i in range(n):
       some_obj[n] = "_"     # Сложность O(1)


@benchmark
def filling_l(some_obj, n):  # Сложность O(n)
    for i in range(n):
        some_obj.append("-")  # Сложность O(1)


@benchmark
def my_updating_d(some_obj, n):
    for i in range(n):
        some_obj[i] = "_"  # Сложность O(1)

@benchmark
def my_updating_l(some_obj, n):
    for i in range(n):
        some_obj[i] = "-" # Сложность O(1)


@benchmark
def my_updating_l2(some_obj, n):
    for i in range(n):
        some_obj.insert(0, '-')


@benchmark
def my_del_l(some_obj, n):
    for i in some_obj:
        some_obj.remove(i) # Сложность O(n)


@benchmark
def my_del_d(some_obj, n):
    for i in range(n):
        some_obj.pop(i) # Сложность O(1)



my_dict = dict()
my_list = []
print(f'Сравнение заполнения')
print('Словарь')
filling_d(my_dict, n)
print('Список')
filling_l(my_list, n)

"""
Словарь заполнился чуть-чуть быстрее. Видимо есть разница в том, как заполнять.
Словарь
[*] Время выполнения: 0.004755973815917969 секунд.
Список
[*] Время выполнения: 0.008920907974243164 секунд.
"""

print(f'\nСравнение обновления данных')
print('Словарь')
my_updating_d(my_dict, n)
print('Список по индекcу')
my_updating_l(my_list, n)
print('Список insert')
my_updating_l2(my_list, n)
"""
При обновлении данных, словарь медленее. Т.к. обновление по индексу быстрее, чем по ключу, 
но через insert очень медленно.
Сравнение обновления данных
Словарь
[*] Время выполнения: 0.005222320556640625 секунд.
Список по индекcу
[*] Время выполнения: 0.0037834644317626953 секунд.
Список insert
[*] Время выполнения: 6.487040042877197 секунд.
"""

print(f'\nСравнение удаления данных')
print('Словарь')
my_del_d(my_dict, 10000)
print('Список')
my_del_l(my_list, 10000)

""""
Сравнение удаления данных
Удвление быстрее по ключу, т.к. словать это хеш таблица
Словарь
[*] Время выполнения: 0.000993967056274414 секунд.
Список
[*] Время выполнения: 3.8934338092803955 секунд.
"""