"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать, так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!

Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""


import time


def time_check(action):
    def wrapper(*args):
        start = time.time()
        result = action(*args)
        finish = time.time()
        print(f'Время выполнения: {finish - start}\n')
        return result

    return wrapper

#Сложность O(n)

@time_check
def list_new(num):
    result = []
    for item in range(num):
        result.append(item)
    return result


#Сложность O(n)

@time_check
def dict_new(num):
    result = dict()
    for item in range(num):
        result[item] = item
    return result


LIMIT = 15323544

print('Cписок: ')
test_list = list_new(LIMIT)

print('Cловарь: ')
test_dict = dict_new(LIMIT)

#Словарь заполняется немного медленнее, чем список, т.к. время уходит на формирование хеш-таблицы(ключ-значение)


#Умножение элементов списка и словаря на число

@time_check
def mul_list(lst, num):
    for idx in range(len(lst)):
        lst[idx] *= num
    return lst


@time_check
def mul_dict(dct, num):
    for item in dct:
        dct[item] *= num
    return dct


NUMBER = 24

print('Cписок: ')
mul_list(test_list, NUMBER)

print('Словарь: ')
mul_dict(test_dict, NUMBER)

#Время умножения элементов списка на число меньше, чем элементов словаря на число. Получение значения в списке
#происходит по индексу, а в словаре происходит процесс хеширования ключей для получения позиции значения в хеш-таблице


#Получение индекса по значению элемента в списке

@time_check
def sch_idx(lst, num):
    for item in range(num):
        lst.index(item)
    return lst


LIMIT = 11000

print('Cписок: ')
test_list = list_new(LIMIT)

print('Ищем индексы по значениям в списке:')
sch_idx(test_list, LIMIT)

#Поиск индексов по значениям элементов в словаре происходит очень долго(перебор всех элементов), поэтому если
#нужно быстро получить значение какого-либо элемента, лучше использовать словарь (поиск по ключу) -
# константная сложность.


#Очистка списка и словаря

@time_check
def clear_list():
    test_list.clear()

@time_check
def clear_dict():
    test_dict.clear()

print('Cписок: ')
clear_list()

print('Словарь: ')
clear_dict()


#Время очистки списка меньше, чем словаря, т.к. словарь очищает еще и хеш-таблицу.