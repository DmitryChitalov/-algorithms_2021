"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать, так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.
   Операцию clear() не используем.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!

Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""
from time import time
from random import randint


def our_measurements(func):
    def wrap(*args):
        start_time = time()
        r = func(*args)
        print(time() - start_time)
        return r

    return wrap


print('Время заполнения списка и словаря:')


@our_measurements
def filling_list(n):
    lst = [randint(0, 10000) for _ in range(n)]
    return lst


@our_measurements
def filling_dict(n):
    dct = {'key_' + str(_): randint(0, 10000) for _ in range(n)}
    return dct


lst1 = filling_list(1000000)
dct1 = filling_dict(1000000)

# Быстрее заполняется список (в приведенном примере в полтора - два раза), т.к. он ен хешируем,
# и в него добавляются значени в конец по одному
# В словари все же вносятся пары элементов. Да еще и считается хеш (я так понимаю, дополнительно строитися индекс
# ввиду того, что доступ до элемента осуществляется за время О(1))


print('\nВремя копирования списка и словаря:')


@our_measurements
def cp(item):
    return item.copy()


lst1 = cp(lst1)
dct1 = cp(dct1)

# Список копируется быстрее в силу вышеописанных вещей. Часто, однако, время показывается как ноль(быстрая операция)

print('\nВремя удаления (извлечения) первых 1000 элементов списка и словаря:')


@our_measurements
def rm_list(lst):
    for i in range(1000):
        lst.pop(i)


@our_measurements
def rm_dict(dct):
    for i in range(1000):
        dct.pop('key_' + str(i))


rm_list(lst1)
rm_dict(dct1)

# Доставать первые (или серединные) элементы лучше из словаря, поскольку он индексирован,
# и сложность опервции в этом случае О(1), а не О(n), как у списка.


print('\nВремя удаления (извлечения) последних 1000 элементов списка и словаря:')


# У словаря нет конца, так что для его оценки подойдет функция из примера выше. Только ключи поменяем,
# чтобы все не поломалось.


@our_measurements
def rm2_list(lst):
    for i in range(1000):
        lst.pop()


@our_measurements
def rm2_dict(dct):
    for i in range(1000, 2000):
        dct.pop('key_' + str(i))


rm2_list(lst1)
rm2_dict(dct1)

# Значения тут уже почти одинаковые, то одно больше, то другое, поскольку сложность будет и там и там О(1)

