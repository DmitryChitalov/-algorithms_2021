"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать, так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!

Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""

""" Ниже представлено решение и результаты 
при разном клоичестве повторений в циклах функции-декоратора """

import time


def time_execution(func):
    """ 
    :param func: функция-декоратор для определения времени выполнения создаваемх функций
    """
    def measuring():
        """
        :return: возвращает данные о времени выполнения операции
        """
        n = 10000  # количество циклов
        start_val = time.time()
        for i in range(n):  # O(n)
            func(i)         # будет зависеть от функции, которую передаем
        end_val = time.time()
        return n, end_val - start_val
    return measuring


# ----- Общие параметры ----
test_list = []          # обрабатываемый список
test_dict = {}          # обрабатываемый словарь
insert_val = 'mytext'   # добавляемый текст


# 1. Работа со списком
# -- 1.1 Заполнение списка
@time_execution
def list_append(num=None):        # O(1)
    test_list.append(num)         # О(1)


res_list_append = list_append()

test_list.sort(reverse=True)  # сделал обратную сортировку, но не сильно влияет на результат

# -- 1.2 Получение значения из списка по индексу
@time_execution
def list_val(num=None):         # O(n)
    val = test_list[num]
    # для сравнения со словарем тут будет справедливо добавить index()
    val = test_list[test_list.index(num)]  # О(1) и О(n) для index() = О(n)


res_list_val = list_val()


# -- 1.3 Копирование списка в новый список()
@time_execution
def list_copy(num=None):         #O(n)
    new_list = test_list.copy()  # O(n)


res_list_copy = list_copy()


# -- 1.4 Удаление из списка с помощью pop()
@time_execution
def list_pop(num=None):   # O(n)
    """ Если просто использовать pop, то будет
    не самое корректное сравнение с аналогичной операцией в словаре.
    Для корректностии сравнения результатов используется поиск значения
    через index (будет 0 всегда), а потом с этим индексом используется pop """
    # test_list.pop()  - т.е. так решил не делать
    test_list.pop(test_list.index(num))  # pop() - O(1), index() - O(n)


res_list_pop = list_pop()

# Выводим результаты по спискам
all_res_list = [res_list_append, res_list_val, res_list_copy, res_list_pop]

# 2. Работа со словарем
# -- 2.1 Заполнение словаря
""" Ключ - порядковый номер, значение - одинаковое """


@time_execution
def dict_add(num=None):             #O(1)
    test_dict[num] = insert_val     #O(1)


res_dict_add = dict_add()


# -- 2.2 Чтение данных из словаря


@time_execution
def dict_val(num=None):     # O(1)
    test_dict.get(num)      # O(1)


res_dict_val = dict_val()


# -- 2.3 Копирование данных из словаря

@time_execution
def dict_copy(num=None):         # O(n)
    new_dict = test_dict.copy()  # O(n)


res_dict_copy = dict_copy()


# -- 2.4 Удаление данных из словаря

@time_execution
def dict_pop(num=None):     # O(1)
    test_dict.pop(num)      # O(1)



res_dict_pop = dict_pop()

# Cохраняем результаты по словарям
all_res_dict = [res_dict_add, res_dict_val, res_dict_copy, res_dict_pop]


name_metod = ['Добавление значения:', 'Получение значения:', 'Копирование объекта:', 'Удаление значения:']
print('Количество циклов:', all_res_dict[0][0])
print('{0:^25.25}'.format('Тип операции'), '{0:^1.9}       {1:^1.9}'.format('Список', 'Словарь'))
print('-'*50)
for i in [[i_list[0], round(i_list[1][1], 7), round(i_list[2][1], 7)]
          for i_list in zip(name_metod, all_res_list, all_res_dict)]:
    # print('\t'.join(map(str, i)))
    print('{0:25.25}'.format(i[0]), '{0:0.9}     {1:0.9}'.format(i[1], i[2]))


""" ВЫВОДЫ:

    1. Добавление значений в словарь может быть медленее, чем в список, что
    объясняется необходимостью подсчитать значение хеша ключа при каждом добавлении, но не значительное отличие. 
    В списках для добавления значения данная операция не выполняется. Учитывая то, что сложность операций 
    в обоих случаях одинакова, можно предположить, что затраты времени будут примерно одинаковыми.  
    
    2. Получение/удаление значений из словаря (с поиском по ключу) будет эффективныее 
    за счет использования хеша словарем - сложность О(1). 
    В списке, учитывая необходимость сопоставимости условий решения для целей сравнения со словарем, 
    исползовался метод index() с О(n), который предполагает проход по всем значениям, 
    а далее получали/убиралось найденно значение по индексу методом pop() с O(1) - т.е. в данном случае 
    сложность операции будет О(n).
    Если посмотреть общую сложность после цикла, то в предложенном варианте для словаря это будет O(n), 
    а для списка О(n^2), поэтому на больших списках затраты времени при работе со словарем будут 
    увеличиваться незначительно, а вот со списком будут проблемы значительные - см. ниже результаты. 
    
    3. Копирование списка будет занимать меньше времени по причине отсуствия процесса хеширования.
    Работа со словарем в данном случае проигрывает - в результатах это 4-6 раза. Сложность обоих вариантов О(n). 

    См. результаты замеров ниже:
"""


# Анализ результатов:

# Количество циклов: 5000
#       Тип операции        Список       Словарь
# --------------------------------------------------
# Добавление значения:      0.0009978     0.0009975
# Получение значения:       0.1560905     0.0009966
# Копирование объекта:      0.0573559     0.2517095
# Удаление значения:        0.1416223     0.0009878

# Количество циклов: 10000
#       Тип операции        Список       Словарь
# --------------------------------------------------
# Добавление значения:      0.0019948     0.0019948
# Получение значения:       0.5795672     0.0029914
# Копирование объекта:      0.3940175     0.8871443
# Удаление значения:        0.8387809     0.0029914

# Количество циклов: 25000
#       Тип операции        Список       Словарь
# --------------------------------------------------
# Добавление значения:      0.0039899     0.0039897
# Получение значения:       3.4448721     0.0039892
# Копирование объекта:      2.1012337     15.6006796
# Удаление значения:        3.7634284     0.0059838

# Количество циклов: 50000
#       Тип операции        Список       Словарь
# --------------------------------------------------
# Добавление значения:      0.0089762     0.0159559
# Получение значения:       13.8223524     0.0149608
# Копирование объекта:      8.1374288     63.6271679
# Удаление значения:        19.6904223     0.0119693

# Количество циклов: 100000
#       Тип операции        Список       Словарь
# --------------------------------------------------
# Добавление значения:      0.0209444     0.0169566
# Получение значения:       74.0734324     0.0179517
# Копирование объекта:      42.8653769     226.3023
# Удаление значения:        57.1279428     0.0169511
