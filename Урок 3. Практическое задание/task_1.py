"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать, так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!

Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""

import time


# Создадим декоратор который будет замерять время работы функции.
def stopwatch(fnc):
    def warp(n):
        t = time.time()
        res = fnc(n)
        print(time.time() - t)
        return res
    return warp


@stopwatch
# O(n)
def fill_dict(n):
    return {i: i for i in range(n)}                # return имеет сложность O(1), Dictionary Comprehension O(n)


@stopwatch
# O(n)
def fill_list(n):
    return [i for i in range(n)]                   # return имеет сложность O(1), List Comprehension O(n)


"""
В моем случае время заполнения словаря заняло почти в 2 раза больше времени, чем заполнение списка. 
Это связано с тем что в словаре происходит хеширование данных.
"""


@stopwatch
# Синтаксис и сложность алгоритма получения элемента по индексу/коючу у списка и словаря одинаковая и имеет сложность:
# O(1) Замерить время выполнения не удалось, так как функция time() выдает 0.0 для обоих случаев.
# Если перебирать все элементы то выдает примерно одинаковые результаты, около 3,5 секунд.
def pull_el(arr_for_pull):
    el = len(arr_for_pull) // 2                                           # O(1)
    print(arr_for_pull[el])                                               # O(1)


@stopwatch
# O(n^2)
def push_el_list_1(list_for_push):
    for i in range(1000):                                                 # O(n)
        list_for_push.insert(0, len(list_for_push))                       # O(n)


@stopwatch
# O(n)
def push_el_list_2(list_for_push):
    for i in range(1000):                                                 # O(n)
        list_for_push.append(len(list_for_push))                          # O(1)


@stopwatch
# O(n)
def push_el_dict(dict_for_push):
    for i in range(1000):                                                 # O(n)
        dict_for_push[len(dict_for_push)] = len(dict_for_push)            # O(1)


@stopwatch
# O(n) для словарей
# O(n^2) для списков
def del_el(arr_for_del):
    for i in range(10000):                                                # O(n)
        del arr_for_del[i]                                                # O(1) для словарей, O(n) для списков


"""
Как можно увидеть из замеров времени выполнеия, операции добавлению/удалению элементов, не в конец списка, выполняются 
в разы медленее, чем операции по добавлению/удалению элементов из словаря по ключу. Это связано с тем что при выполнении
данных операций в списке необходимо "передвинуть" все элементы, а это по сути переприсваивание значений. В словарях нет 
такой необходимости.
"""

count_vol = 1000000
my_dict = fill_dict(count_vol)
my_list = fill_list(count_vol)

pull_el(my_dict)
pull_el(my_list)

push_el_list_1(my_list)
push_el_list_2(my_list)

print(len(my_dict))
push_el_dict(my_dict)
print(len(my_dict))

del_el(my_dict)
print(len(my_dict))

print(len(my_list))
del_el(my_list)
print(len(my_list))


