"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать, так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!

Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""
import random
import time


def timer(func):
    def wrapped(*args):
        start = time.perf_counter_ns()
        res = func(*args)
        print(f'{(time.perf_counter_ns() - start) / 1000000}ms')
        return res

    return wrapped


# Сложность O(n), т.к. для заполнения используется цикл.
# Время выполнения обеих функций примерно одинаковое, но при малом количестве элементов заполнение словаря происходит
# чуть медленнее, видимо из-за того, что это хэш-таблица.
@timer
def dict_fill(length):
    return {idx: random.randint(0, 100) for idx in range(length)}


# Сложность O(n).
@timer
def list_fill(length):
    return [random.randint(0, 100) for _ in range(length)]


# O(1) Сложности функций одинаковы, и получение элементов словаря и списка работают примерно одинаково.
@timer
def dict_get(dic):
    for idx in range(2000):
        f = dic[idx]
    return f


# O(1)
@timer
def list_get(lst):
    for idx in range(2000):
        f = lst[idx]
    return f


# O(n) Удаление элемента словаря имеет константную сложность, поэтому из словаря элементы удаляются быстрее.
@timer
def dict_del(dic, count):
    for i in range(count):  # O(n)
        del dic[i]  # O(1)
    return dic


# O(n^2) Удаление элемента списка имеет линейную сложность, поэтому из списка элементы удаляются медленнее.
@timer
def list_del(lst, count):
    for i in range(count):  # O(n)
        del lst[i]  # O(n)
    return lst


# O(n) Сложность линейная, но время выполнения увеличивается из-за поиска ключа последнего элемента.
@timer
def dict_add(dic, count):
    last_el = list(new_dict)[-1]
    for i in range(count):
        dic[last_el + i] = random.randint(0, 100)
    return dic


# O(n) Сложность тоже линейная, но работает быстрее, потому что не нужно искать ключ элемента. Новый элемент просто
# добавляется в конец списка. Но если убрать циклы, то элементы словаря и списка будут добавляться с одной скоростью,
# потому что эти операции имеют сложность O(1).
@timer
def list_add(lst, count):
    for _ in range(count):
        lst.append(random.randint(0, 100))
    return lst


delimiter = '\n----------------------------------------------------------------------'

new_dict = dict_fill(2000)
print(f'Заполнение словаря:\n{new_dict}{delimiter}')

new_list = list_fill(2000)
print(f'Заполнение списка:\n{new_list}{delimiter}')

print(f'Получение элемента словаря:\n{dict_get(new_dict)}{delimiter}')
print(f'Получение элемента списка:\n{list_get(new_list)}{delimiter}')
print(f'Добавление элемента словаря:\n{dict_add(new_dict, 2000)}{delimiter}')
print(f'Добавление элемента списка:\n{list_add(new_list, 2000)}{delimiter}')
print(f'Удаление элемента словаря:\n{dict_del(new_dict, 2000)}{delimiter}')
print(f'Удаление элемента списка:\n{list_del(new_list, 2000)}{delimiter}')
