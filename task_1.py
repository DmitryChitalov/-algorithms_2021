"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Оптимизируйте, чтобы снизить время выполнения
Проведите повторные замеры.

Добавьте аналитику: что вы сделали и почему!!!
Без аналитики задание не принимается

И прошу вас обратить внимание, что то, что часто ошибочно называют генераторами списков,
на самом деле к генераторам отношения не имеет. Это называется "списковое включение" - list comprehension.
"""


import timeit


def create_list():
    return [num for num in range(1000001)]


def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


def func_2(nums):
    return [idx for idx in range(len(nums)) if nums[idx] % 2 == 0]


# Я решил использовать list comprehension для оптимизации, потому что это выглядит очень лаконично, но я не был уверен,
# что это приведет к ускорению работы. Проведя замеры я выяснил, что он все таки быстрее, но ответить почему я не
# могу. Возможно из-за того, что у нас как бы нет списка как в первом варианте new_arr и нет метода append, видимо,
# внутри оно реализовано более хитро, что и дает прирост производительности где-то на 15-20% при равной сложности в
# O нотации.


if __name__ == '__main__':
    a = timeit.timeit('func_1(create_list())', globals=globals(), number=1000)
    b = timeit.timeit('func_2(create_list())', globals=globals(), number=1000)
    print(a, b, a / b)