"""
2. Отсортируйте по возрастанию методом слияния одномерный вещественный массив,
заданный случайными числами на промежутке [0; 50).

Выведите на экран исходныйи отсортированный массивы.

Хотя в примерах к уроку уже есть вариант реализации слияния,
попробуйте предложить другой (придумать или найти).

И попытаться сделать замеры на массивах разной длины: 10, 100, 1000, ...

Пример:
Введите число элементов: 5
Исходный - [46.11436617832828, 41.62921998361278, 18.45859540989644, 12.128870723745806, 8.025098788570562]
Отсортированный - [8.025098788570562, 12.128870723745806, 18.45859540989644, 41.62921998361278, 46.11436617832828]
"""



"""
Сортировка слиянием, из урока использует подход сверху вниз. Другой подход, то есть восходящий, 
работает в противоположном направлении, БЕЗ РЕКУРСИИ 
(работает итеративно) — если наш массив имеет N элементов, мы делим его на N подмассивов ОДНОГО элемента и 
сортируем пары смежных одноэлементных массивов, затем сортируем соседние пары двухэлементных массивов и т. д.
"""
import timeit
import random

def MergerSort(a):
    def MergerGroup(a, left, m, right):
        if left >= right: return None
        if m < left or right < m: return None
        t = left
        for j in range(m + 1, right + 1):  # подгруппа 2
            for i in range(t, j):  # цикл подгруппы 1
                if a[j] < a[i]:
                    r = a[j]
                    # итерационно переставляем элементы, чтобы упорядочить
                    for k in range(j, i, -1):
                        a[k] = a[k - 1]
                    a[i] = r
                    t = i  # проджолжение вставки в группе 1
                    break  # к следующему узлу из подгруппы 2

    if len(a) < 2: return None
    k = 1
    while k < len(a):
        g = 0
        while g < len(a):  # группы
            z = g + k + k - 1  # последний эл-т группы
            r = z if z < len(a) else len(a) - 1  # последняя группа
            MergerGroup(a, g, g + k - 1, r)  # слияние
            g += 2 * k
        k *= 2

a = [random.uniform(0, 50) for _ in range(10)]
print(a)
print('Сортировка слияние по восходящей range(10): ', timeit.timeit("MergerSort(a[:])", globals=globals(), number=100))

a = [random.uniform(0, 50) for _ in range(100)]
print('Сортировка слияние по восходящей range(100): ', timeit.timeit("MergerSort(a[:])", globals=globals(), number=100))

a = [random.uniform(0, 50) for _ in range(1000)]
print('Сортировка слияние по восходящей range(1000): ', timeit.timeit("MergerSort(a[:])", globals=globals(), number=100))

"""
В восходящей же просейке сравнения экономятся за счёт того, что родители почти не сравниваются с потомками, 
в основном, только потомки сравниваются друг с другом. В обычной heapsort и родитель сравнивается с потомками 
и потомки сравниваются друг с другом — поэтому сравнений получается почти в полтора раза больше при том же 
количестве обменов.

"""
