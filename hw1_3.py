"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""


#  решение 1
#  идея: создаем список из значений и сортируем его. Три последних значения в отсортированном списке
#   это то три самых больших значения. По этим значениям при помощи созданной функции находим
#   ключи - название компаний. можно три раза обращаться к этой функции, а можно в самой функции сразу
#   искать три ключа по трем переданным значениям. Как оптимальнее? проверим в варианте 2).

def get_key1(my_dict, val):  # функция поиска ключа по значению
    for d_key, d_value in my_dict.items():  # проходим по всем элементам словаря, сложность n
        if val == d_value:
            return d_key
    return "key doesn't exist"


def get_key(my_dict, val1, val2, val3):  # функция поиска ключей по значению
    company_1, company_2, company_3 = '', '', ''
    for d_key, d_value in my_dict.items():  # проходим по всем элементам словаря, сложность n
        if val1 == d_value:
            company_1 = d_key
        if val2 == d_value:
            company_2 = d_key
        if val3 == d_value:
            company_3 = d_key
    return company_1 + ' ' + company_2 + ' ' + company_3
#    return "key doesn't exist"


company = {"Com1": 32, "Com2": 3252, "Com3": 234532, "Com4": 323422, "Com5": 3552, "Com6": 132, "Com7": 344}
lst_value = list(company.values())  # создаем список значений, сложность n, т.к. зависит от "длины" словаря
lst_value_s = sorted(lst_value)  # сортируем список ключей, сложность n
print(get_key1(company, lst_value_s[len(lst_value) - 1]))  # сложность n
print(get_key1(company, lst_value_s[len(lst_value) - 2]))  # сложность  n
print(get_key1(company, lst_value_s[len(lst_value) - 3]))  # сложность  n

# решение 2.
#  то же что и решение 1, только ищем сразу в одном  переборе  все три значения
#


# company = {"Com1": 3288, "Com2": 3252, "Com3": 234532, "Com4": 323422, "Com5": 3552, "Com6": 132, "Com7": 344}

lst_value = list(company.values())  # создаем список значений, сложность n, т.к. зависит от "длины" словаря
lst_value_s = sorted(lst_value)  # сортируем список значений, сложность n
print('способ 2.')
print(get_key(company, (lst_value_s[len(lst_value) - 1]),
              lst_value_s[len(lst_value) - 2], lst_value_s[len(lst_value) - 3]))  # сложность n

# решение 3.
#  Создаем три цикла. В первом цикле находим самое большое значение,
#  во втором и третьем циклах находим второе и третье наибольшие значения
#  затем по значению находим ключ (название компании) используя функцию get_key()


# company1 = {"Com1": 32888, "Com2": 3252, "Com3": 234532, "Com4": 323422, "Com5": 3552, "Com6": 132, "Com7": 344}


max1, max2, max3 = 0, 1, 2
for key, value in company.items():  # сложность линейная, n
    if company.get(key) > max1:
        max1 = company.get(key)
for key, value in company.items():  # сложность линейная, n
    if max1 > company.get(key) > max2:
        max2 = company.get(key)
for key, value in company.items():  # сложность линейная, n
    if max1 > company.get(key) > max3 and company.get(key) < max2:
        max3 = company.get(key)
print('способ 3')
print(get_key1(company, max1), get_key1(company, max2), get_key1(company, max3))  # сложность n
#
# в первом решении сортируем один раз (1*n), три раза обращаемся к функции поиска ключа по значению (3*n)
# сложность первого решения 4*n
#
# во втором решении  три цикла (3*n), и три раза обращаемся к функции поиска ключа по значению  (3*n)
# сложность второго решения 6*n
#
# вывод: первое решение эффективнее по времени выполненения.
